# "自己构建"哲学：依赖最小化的文化转变

## 文章来源

**标题**：Build It Yourself
**作者**：Armin Ronacher（Flask、Click、Jinja2 作者）
**发表日期**：2025年1月24日
**核心观点**：我们需要一场文化转变——庆祝更少的依赖而非更多

---

## 核心问题：依赖滚动

### 什么是"依赖滚动"（Dependency Churn）？

**定义**：永无止境的更新、补丁、审计和传递依赖的跑步机。

**现象**：
```bash
# 你只是想修个 bug
$ cargo upgrade

# 实际发生：
更新 28 个包
下载 15 MB
编译 10 分钟
...只是为了修复一个你甚至没遇到的 bug
```

**作者的吐槽**：
> "谁不喜欢等待又一次 cargo upgrade，只是为了修复一个你根本没有的 bug？"

---

## 依赖爆炸的真实数据

### Rust 生态的案例


| 项目类型 | 直接依赖 | 实际依赖（crates） |
|---------|---------|-------------------|
| **Tokio 新项目** | 1 | 28 |
| **Rocket 新项目** | 1 | 172 |
| **MiniJinja 库** | 0 | 1（只有 serde） |
| **MiniJinja CLI** | ? | 142 |



**对比**：
- 同一个库，CLI 版本比库版本多 **141 个依赖**
- 为什么？因为 CLI 需要命令行解析、颜色输出等功能


---

## terminal_size 案例：深度剖析

### 案例背景

**包名**：`terminal_size`
**功能**：获取终端尺寸（如 80x25 或 120x40）
**底层 API**：50 年前就已稳定

### 问题分析

**作者的困惑**：

```
一个功能：
- 底层 API 50 年未变
- 只需调用一个系统函数
- 返回两个数字

结果：
- 引入 3-4 个额外的 crate
- 触发连锁反应
- 编译数千行其他代码
- 26 次版本发布
```

**作者的对比**：
> "我自己 10 年前写的版本，一次更新都不需要。因为震惊：获取终端尺寸的方法没有改变。"

### 为什么 terminal_size 有这么多更新？

**答案**：不是因为功能变了，而是因为：

```
terminal_size
└── 依赖平台抽象库 A
    └── 平台抽象库 A 持续滚动更新
        → terminal_size 必须更新以避免代码重复
        → 平台抽象库 A 依赖平台抽象库 B
            → 平台抽象库 B 也在滚动更新
                → 整个依赖链都在滚动
```

**核心问题**：为了避免代码重复和编译时间爆炸，必须跟随依赖链的持续更新。

---

## "大供应链"的说辞

### 他们会告诉你

**"大供应链"（Big Supply Chain）公司的论调**：

1. **不要复制粘贴那个函数到你的库里**
   - "代码重复是邪恶的！"
   - "你应该依赖标准的平台抽象库！"

2. **不要自己写 unsafe 代码**
   - "你没有资格写 unsafe！"
   - "让平台抽象架构师来做！"
   - "否则有人会拍你！"

3. **必须保持依赖更新**
   - "为了安全，你必须有依赖！"
   - "为了安全，你必须保持它们更新！"
   - "尽管大多数安全问题都来自依赖本身"

### 依赖产业链

**作者指出**：有整个公司靠提供工具处理你的依赖混乱而生存。

```
依赖问题
↓
诞生 Dependabot、Snyk、WhiteSource 等
↓
这些公司推动"必须有依赖"的观念
↓
创造更多依赖问题
↓
需要更多工具
↓
循环往复
```

---

## 稳定代码被惩罚

### RUSTSEC 的问题

**RUSTSEC**：Rust 的安全公告数据库（类似评级机构）

**作者的经历**：
```
你的依赖：
- 代码完美运行
- 没有已知 bug
- 但 bug tracker 不太活跃

结果：
RUSTSEC 给你"垃圾评级"
```

**讽刺**：
> "在 Rust 生态系统中，稳定的代码会被惩罚。"

### 代码的理想状态

**作者的观点**：

```

代码的目标应该是：
✓ 写成不需要更新的方式
✓ 最终达到某种稳定状态
✓ 可以静静地工作数年

不应该是：
✗ 持续的维护跑步机
✗ 每周都有新版本
✗ 永远在追赶依赖更新

```

---

## 更简单的路径：自己写

### 传统观点

**问题**：
- "自己写太费时间了！"
- "重复造轮子！"
- "你的实现可能有 bug！"

### 2025 年的现实

**AI 辅助开发**：

```bash
# 传统方式（15 分钟）
1. 搜索 npm/crates.io
2. 找到 3-5 个候选包
3. 阅读文档
4. 评估依赖
5. 安装
6. 学习 API
7. 集成到代码


# AI 方式（2 分钟）
1. 告诉 ChatGPT/Cursor："写一个函数获取终端尺寸"
2. 得到无依赖的代码
3. 复制粘贴
4. 完成
```

**作者的论断**：
> "现在是 2025 年，让 ChatGPT 或 Cursor 生成一个无依赖的实现，比研究一个依赖更快。"

### 维护成本对比

**依赖方式**：
```
安装：1 分钟
使用：5 分钟
持续维护：
  - 每月检查更新
  - 每季度升级版本
  - 处理破坏性变更
  - 审计安全漏洞
  - 解决依赖冲突
总计：数小时/年
```

**自己实现**（简单功能）：
```
实现：10 分钟
使用：5 分钟
持续维护：0 分钟（代码稳定）
总计：15 分钟，一次性
```

**结论**：对于简单函数，维护开销远小于依赖更新的开销。

---

## 企业文化的感染

### 代码审查文化的问题

**现象**：
```
工程师 A：引入一个新的闪亮库
管理层：👏 "多么模块化！多么可组合！"

工程师 B：自己实现了 20 行代码
管理层：🤔 "为什么不用现成的库？"
```

**结果**：
- 公司更可能奖励而非批评引入新库的工程师
- 创造了问题
- Dependabot 诞生
- 整个内部工程团队忙于：
  - Vendoring 依赖
  - 内部审计
  - 全公司范围的升级

### 开源社区被感染

**培训效应**：
```
每个新员工都被训练：
✓ 依赖是好的
✓ 代码复用是好的
✓ 有旧代码是坏的工程文化的标志

结果：
✗ 很难说服他们最小化依赖
✗ 很难说服他们自己实现
✗ 被视为"不现代"
```

---

## 作者的挫败：sha1-smol 案例

### 故事背景

**几年前**：
- 作者写了 `sha1` crate（计算 SHA1 哈希）
- 简单、无依赖
- 成为标准的 SHA1 计算包

**压力来了**：
- 被要求捐赠包名给 rust-crypto
- 被要求依赖整个 crypto 生态系统
- 理由："生态系统已经很成熟了"

**结果**：

```

旧的 sha1（作者版本）：
└── 0 个依赖

新的 sha1（rust-crypto 版本）：
└── 10 个依赖

```

**作者的感受**：
> "在对话中，我是唯一推动保持低依赖的人，这让我感到疲惫。"

**为什么妥协？**
- 包名在注册表中很珍贵
- 人们想要 trait 兼容性
- 无法独自对抗整个生态系统的压力

---

## 我们需要的文化转变

### 现在被庆祝的

```
❌ "看我的代码多模块化！"
❌ "我只写了 5 行，其他都是复用！"
❌ "我们集成了 50 个微服务！"
❌ "这个库有 1000 个星星！"
```

### 应该庆祝的



```
✅ 工程师自己实现了小函数
✅ 最小的依赖图
✅ 多年不需要触碰的代码（因为一次就做对了）
✅ 构建低依赖或零依赖的开源库
```



### 何时应该自己构建？

**自己写**（Build It Yourself）：
- 功能简单（<20 行代码）
- 底层 API 稳定
- 维护成本低
- 你能理解和控制代码

**使用库**（Use Library）：
- 解决复杂问题（图形、加密、网络协议）
- 需要跨平台抽象
- 有活跃维护
- 你的核心业务不在此

**作者的例子**：
> "当然不是非黑即白。有些重要的库解决了困难问题。图形库抽象了复杂的驱动，HTTP 和 QUIC 的实现。我无法摆脱 tokio，也不想摆脱。但当你使用一个函数，却编译了数百个函数时，应该有警钟响起。"

---

## MiniJinja 的榜样

### 作者的自豪

**MiniJinja README 中的展示**：

```bash
$ cargo tree
minimal v0.1.0 (examples/minimal)
└── minijinja v2.6.0 (minijinja)
    └── serde v1.0.144
```

**只有一个依赖！**

### 更进一步

**PR 目标**：最终去掉最后一个依赖（serde）

**作者的计划**：
> "今年我会自豪地修剪我所有项目中的肥肉。"

---

## 实际例子：该自己写还是用库？

### 例子1：终端尺寸

**用库**：
```rust
use terminal_size::{Width, Height, terminal_size};

let size = terminal_size();
if let Some((Width(w), Height(h))) = size {
    println!("宽度: {}, 高度: {}", w, h);
}

// 依赖：3-4 个 crate
// 26 次版本更新
```

**自己写**（Unix）：
```rust
use libc::{ioctl, TIOCGWINSZ, winsize};

unsafe {
    let mut size: winsize = std::mem::zeroed();
    ioctl(0, TIOCGWINSZ, &mut size);
    println!("宽度: {}, 高度: {}", size.ws_col, size.ws_row);
}

// 依赖：1 个（libc，无法避免）
// 10 年不需要更新
```

### 例子2：判断奇偶

**用库**：
```rust
use is_odd::is_odd;

if is_odd(5) {
    println!("奇数");
}

// 依赖：2 个（is-odd + is-number）
```

**自己写**：
```rust
fn is_odd(n: i32) -> bool {
    n % 2 == 1
}

if is_odd(5) {
    println!("奇数");
}

// 依赖：0 个
// 维护成本：0
```

### 例子3：Left Pad

**用库**：
```javascript
import leftPad from 'left-pad'

console.log(leftPad('123', 5, '0'))  // '00123'

// 依赖：1 个
// 风险：2016 年全球项目崩溃
```

**自己写**（现代 JS）：
```javascript
'123'.padStart(5, '0')  // '00123'

// 依赖：0 个（原生 API）
// ES2017+ 支持
```

---

## 何时必须用库？

### 复杂问题的例子

**1. 加密算法**
```rust
// ❌ 不要自己实现
fn my_sha256(data: &[u8]) -> [u8; 32] {
    // 自己实现加密算法几乎肯定有安全漏洞
}

// ✅ 使用成熟的库
use sha2::{Sha256, Digest};
let hash = Sha256::digest(data);
```

**2. HTTP/2、QUIC 协议**
```rust
// ❌ 不要自己实现
// 这些协议极其复杂

// ✅ 使用 tokio、hyper、quinn 等
```

**3. 跨平台图形**
```rust
// ❌ 不要自己抽象 OpenGL/Vulkan/Metal/DirectX

// ✅ 使用 wgpu、gfx-hal 等
```

### 判断标准

| 标准 | 自己写 | 用库 |
|------|--------|------|
| **代码行数** | <100 行 | >500 行 |
| **复杂度** | 简单逻辑 | 复杂算法/协议 |
| **安全性** | 无安全影响 | 加密、认证等 |
| **跨平台** | 单平台或简单抽象 | 复杂的跨平台需求 |
| **维护成本** | 几乎无 | 需要跟进标准/漏洞 |

---

## libc 例外

### 唯一无法避免的依赖

**作者的声明**：
> "声明：UNIX 上你需要一个依赖：libc。因为 Rust 不暴露平台的 libc 常量，且它们不标准化。但这是如此常见和轻量的依赖，无论如何你都无法避免它。"

**为什么？**
```rust
// Rust 标准库不提供这些常量
TIOCGWINSZ  // 获取终端尺寸的 ioctl 命令
O_RDONLY    // 打开文件的标志
EPERM       // 错误码

// 必须通过 libc crate 获取
use libc::{TIOCGWINSZ, O_RDONLY, EPERM};
```

---

## 行动呼吁

### 作者的愿景

**我们需要这种文化转变（Vibe Shift）**：

1. **庆祝自己构建**（当合适时）
2. **对大型依赖图保持怀疑**
3. **赞扬构建低依赖开源库的作者**
4. **质疑"必须有依赖"的教条**

### 具体行动

**作为开发者**：
```
□ 评估每个依赖的必要性
□ 对于<20 行的功能，考虑自己实现
□ 使用 AI 工具生成无依赖代码
□ 在 README 中自豪地展示低依赖
□ 支持和赞扬低依赖的项目
```

**作为库作者**：
```
□ 最小化依赖
□ 在文档中展示依赖图
□ 考虑功能特性（features）让用户选择依赖
□ 将可选功能做成可选依赖
□ 记录为什么需要每个依赖
```

**作为公司/团队**：
```
□ 奖励减少依赖的工程师
□ 在代码审查中质疑新依赖
□ 建立依赖审批流程
□ 定期审计和清理依赖
□ 培训团队评估依赖必要性
```

---

## 总结

### 核心信息

1. **依赖滚动是瘟疫**
   - 永无止境的更新
   - 大多数是你不需要的修复

2. **稳定代码被惩罚**
   - RUSTSEC 给不活跃的包垃圾评级
   - 即使代码完美运行

3. **2025 年的现实**
   - AI 生成代码比研究依赖更快
   - 对于简单功能，维护成本 < 依赖成本

4. **企业文化推波助澜**
   - 奖励引入新库
   - 创造 Dependabot 产业

5. **我们需要文化转变**
   - 庆祝更少的依赖
   - 庆祝稳定的代码
   - 庆祝自己构建

### 金句

> "代码的目标应该是不需要更新。"

> "2025 年，让 AI 生成无依赖代码比研究依赖更快。"

> "当你使用一个函数，却编译数百个函数时，警钟应该响起。"

> "在对话中，我是唯一推动保持低依赖的人，这让我感到疲惫。"

### 最终呼吁

> "是时候有新的视角了：我们应该赞扬自己写小函数而不是引入传递依赖网络的工程师。我们应该对大型 crate 图保持怀疑。被庆祝的应该是最小依赖、默默完成工作的谦卑函数、不需要触碰多年的代码，因为它一次就做对了。"

---

## 延伸思考

### 问题1：这适用于所有语言吗？

**答案**：部分适用。

- **Rust/JavaScript**：微包文化严重，最需要这种转变
- **Python**：相对温和，但仍有微包问题
- **Go**：标准库丰富，已经倾向于最小依赖
- **Java**：Spring 生态相对稳定，但也有依赖地狱

### 问题2：AI 真的能替代所有简单依赖吗？

**答案**：大部分可以，但要注意：

✅ AI 擅长：
- 简单算法
- 字符串处理
- 数学计算
- 常见模式

❌ AI 不擅长：
- 安全关键代码
- 性能优化
- 边界情况处理
- 跨平台兼容性

**建议**：AI 生成的代码需要审查和测试。

### 问题3：这会杀死开源社区吗？

**答案**：不会，但会改变方向。

- ❌ 不再：1000 个只有 10 行的微包
- ✅ 而是：100 个解决实际复杂问题的优质库
- 结果：资金和关注流向真正重要的项目

---

**下一步**：阅读 [02-依赖风险与资金问题.md](./02-依赖风险与资金问题.md) 了解哪些依赖真正值得资助
