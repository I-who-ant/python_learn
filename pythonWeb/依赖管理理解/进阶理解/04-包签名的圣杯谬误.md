# 包签名的圣杯谬误：为什么签名不是万能药

## 文章来源

**标题**：Why Package Signing is not the Holy Grail
**作者**：Armin Ronacher
**发表日期**：2013年7月23日
**核心观点**：包签名是必要的,但远非充分的安全解决方案

---

## 常见的误解

### "只需使用 X！"

**典型场景**：
```
开发者讨论软件包安全
↓
某人建议："只需使用 GPG！"
↓
仿佛这就能神奇地解决所有问题
```

**作者的观察**：
> "很多人把包签名当成某种巫术，可以扔向问题然后神奇地得到'安全'。"

### PyPI 的例子

**现状（2013年）**：
```
PyPI 支持 GPG 签名：
✓ 可以生成签名
✓ 可以上传到 PyPI
✓ ...

问题：
✗ 没有工具使用这些签名
✗ 即使使用，也无法信任
```

**为什么？**因为缺少信任模型��

---

## 简单部分：生成签名

### 技术上很容易

**可用技术**：
```
选项：
- OpenPGP（GPG）
- NaCl
- X.509 证书（Verisign 等）
- 其他各种签名技术
```

**实现**：
```python
# 使用 GPG 签名包
gpg --detach-sign --armor my-package-1.0.tar.gz

# 生成 my-package-1.0.tar.gz.asc

# 上传到 PyPI
twine upload my-package-1.0.tar.gz my-package-1.0.tar.gz.asc
```

**很多人止步于此**：
```
签名生成 ✓
签名上传 ✓
声称"有签名验证" ✓
实际安全性...？
```

---

## 困难部分：信任模型

### 核心问题

**验证签名时**：
```
检查签名是否匹配公钥
↓
签名匹配 → 验证通过
↓
但问题是：哪个公钥？
```

**关键**：
> "如果你没有明确定义的信任模型，你所做的只是向问题扔密码学，以便让相关人员能够说他们的系统有签名验证。"

### 什么是信任模型？

**定义**：一套规则，定义如何确定公钥是否可信。

**没有信任模型的后果**：
```
你下载包和签名
你下载公钥
你验证签名
签名匹配公钥
工具说："验证通过！"

但是：
这个公钥可信吗？
这个公钥属于正确的人吗？
答案：不知道
```

---

## 方案1：让送货员告诉你（失败）

### 天真的解决方案

**PyPI 的做法**：
```python
# pip install package
步骤：
1. 从 PyPI 下载包
2. 从 PyPI 下载公钥
3. 验证签名
4. 安装

看起来可行？
```

### 问题所在

**如果攻击者能发送恶意包**��
```
攻击者控制了 PyPI（或中间人攻击）
↓
发送恶意包 + 恶意签名 + 恶意公钥
↓
客户端验证：
  签名与公钥匹配 ✓
↓
客户端愉快地安装恶意包
```

**作者的结论**：
> "如果你信任仓库给你预期的签名密钥和要验证的包，你什么也没获得，只是引入了复杂性。"

### 类比

```
快递员拿来一个包裹
你问："这安全吗？"
快递员说："这是证明安全的证书"
证书也是快递员给你的

你获得了什么？什么也没有。
```

---

## 方案2：Linux 的模式（部分成功）

### Linux 发行版的做法

**机制**：
```
1. Linux 发行版（Debian/Red Hat）内置公钥
2. 安装时验证包签名
3. 不再隐式信任仓库告诉你信任哪个密钥
```

**表面上看起来完美**：
```
你已经知道要信任哪个密钥
↓
验证签名
↓
签名有效 = 包来自可信的构建机器
↓
安全！
```

### 问题1：规模

**适用场景**：
```
Debian/Red Hat:
- 小团队的开发者
- 可以验证每个人
- 签署他们的密钥或授予访问权限

PyPI:
- 任何人都可以注册
- 任何人都可以发布
- 无法验证数千个作者
```

**作者���观点**：
> "PyPI 允许任何人注册并发布，这使得验证作者成为一个无法管理的问题。"

### 问题2：信任构建链

**你不仅仅在信任包作者**：
```
你信任的是：
✓ 包作者
✓ 构建机器
✓ 构建过程
✓ 所有涉及的工具链
```

**风险**：
```
构建机器被入侵
↓
生成恶意但签名有效的包
↓
工具会盲目安装
```

### 唯一优势：镜像验证

**有价值的一点**：
```
验证基于包本身，而不是下载来源
↓
无论从哪个镜像下载
↓
只要签名有效
↓
就知道来自可信的构建机器
```

---

## 方案3：Web of Trust（更接近但仍不足）

### OpenPGP Web of Trust

**概念**：
```
你信任 Alice
Alice 签署了 Bob 的密钥
↓
你传递性地信任 Bob

Bob 签署了 Carol 的密钥
↓
你传递性地信任 Carol

形成信任网络
```

**优点**：
```
✓ 不需要单一权威
✓ 不需要小团队验证每个作者
✓ 去中心化
```

### 关键缺陷：签名的是身份，不是权限

**问题**：
```
你验证了 Bob 的身份
↓
确认这个密钥属于 Bob
↓
但是：
Bob 有权签署 "foo" 包吗？
他也有权签署 "bar" 包吗？（属于 Alice）

Web of Trust 无法回答这个问题
```

**例子**：
```
你信任 Bob 发布 "foo" 包
↓
Bob 的密钥在你的信任网中
↓
Bob 签署了 "bar" 包（实际属于 Alice）
↓
你的工具：签名有效，安装！
↓
你无意中信任了 Bob 签署任何包
```

**作者的总结**：
> "这让我们回到了原始问题：试图确定我们拥有的密钥对这个包是否可信。"

### 问题2：用户体验噩梦

**要求每个发布者**：
```
1. 生成 GPG 密钥对
2. 学习如何使用 GPG
3. 参与密钥签署聚会
4. 让他人签署你的密钥
5. 建立信任路径
```

**结果**：
```
混乱：许多人不理解
懒惰：太麻烦了
能力：不是每个人都能做到

↓
大幅减少愿意发布包的人
```

**更糟的是**：
```
人们为了让包能用而签署密钥
而不是因为真正信任那个人
↓
信任网变得毫无意义
```

---

## 方案4：SSH 模式（Trust On First Use）

### 机制

**SSH 的做法**：
```
第一次连接服务器：
↓
显示服务器公钥指纹
↓
用户确认
↓
保存密钥
↓
以后连接验证此密钥
```

**应用到包管理**：
```
第一次安装包：
↓
提示接受密钥
↓
记住密钥
↓
以后安装验证此密钥
```

### 问题1：第一次仍然脆弱

**明显的问题**：
```
第一次安装时：
↓
如何知道密钥是正确的？
↓
答案：不知道
↓
用户在最脆弱的时候做决定
```

### 问题2：密钥变更

**包可能有多个维护者**：
```
PyPI 上的包：
✓ 转手给新维护者
✓ 被删除后重新注册
✓ 有多个授权发布者

���果：
→ 不同的签名密钥
→ 用户看到"无效签名"警告
```

**用户困境**：
```
收到警告："签名密钥已变更"
↓
用户怎么知道这次变更是 OK 的？
↓
选项 A：去 PyPI 查看
  → 回到隐式信任仓库
选项 B：点击"接受"继续安装
  → 训练用户忽略安全警告
```

### 问题3：临时环境

**现代开发实践**：
```
云服务器：
- 频繁创建销毁
- 每次都是空白状态
- 信任数据库不存在

CI/CD:
- 每次构建都是新环境
- 无法"记住"之前的密钥

Docker 容器:
- 每次运行都是新容器
- 信任数据库消失
```

**结果**：
```
每次都是"第一次安装"
↓
每次都提示接受密钥
↓
要么：
- 总是点"接受"（失去安全性）
- 要么：无法自动化
```

---

## 根本问题：我们到底在信任什么？

### 房间里的大象

**作者的洞察**：
> "在讨论包签名时，房间里的大象是：我们到底在信任什么？"

### 对于 PyPI 这样的仓库

**唯一能信任的**：
```
"根据 PyPI，这个人被允许发布这个包"
```

**关键部分**：
```
"根据 PyPI"
↑
这意味着：
你必须隐式信任 PyPI 告诉你谁拥有哪个包
```

**即使有完美的密钥传输**：
```
完美的信任链 ✓
完美的签名验证 ✓
完美的密钥管理 ✓

但是：
✗ 仍然要信任 PyPI 说"Bob 拥有包 foo"
✗ 如果 PyPI 被攻击者控制
✗ 攻击者说"Eve 拥有包 foo"
✗ 你会信任 Eve 的密钥
```

### 签名不能验证安全性

**重要**：
```
签名验证的是：
✓ 这个包来自拥有这个密钥的人

签名不验证：
✗ 这个人有权发布这个包
✗ 这个包是安全的
✗ 这个人的账号没被盗
```

**恶意包的例子**：
```
攻击者注册包 "hackme"
↓
用 GPG 签名
↓
上传到 PyPI
↓
你安装：
  验证签名 ✓
  签名有效 ✓
  安装恶意代码 ✗
```

**作者的观点**：
> "任何这些系统能够验证的唯一事情是：你获取的包是你想要的包，仅此而已。"

---

## 那么我们该怎么办？

### 作者的坦白

**2013年的立场**：
> "坦白说，我不确定。这不是一个已解决的问题，也不是一个容易解决的问题。"

**2025年的现实**：
- 这个问题仍未解决
- 各种方案都有问题
- 没有完美的解决方案

### 任何解决方案都会有问题

**作者的信念**：
> "我相信无论选择什么解决方案，都会有上面列出的很多问题。"

### 最大的希望

**关键**：
```
最重要的不是签名本身
而是：
终端用户与信任源的关系
```

**不应该是**：
```
包作者 ←→ 信任关系 ←→ 仓库
用户盲目信任仓库
```

**应该是**：
```
用户 ←→ 信任关系 ←→ [信任源]
包作者通过信任源间接获得信任
```

**信任源的选项**：
```
选项1：操作系统（如 Linux 发行版）
选项2：公司内部 PKI
选项3：某种去中心化信任网络
选项4：多个信任源的组合
```

---

## 各种方案对比

### 总结表格

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| **从仓库获取公钥** | 简单 | 无安全价值 | 无 |
| **Linux 模式** | 镜像验证 | 规模问题、信任构建链 | 小规模受控环境 |
| **Web of Trust** | 去中心化 | 验证身份≠验证权限 | 理论上,实际很难 |
| **TOFU (SSH)** | 用户熟悉 | 第一次脆弱、密钥变更 | 手动安装 |

### 共同的缺陷

**所有方案都无法解决**：

1. **谁拥有包名的权威**
   ```
   所有方案最终都回到：
   "谁说这个人可以用这个包名？"
   答案：仓库（PyPI/npm/crates.io）
   ```

2. **验证安全性**
   ```
   签名只能验证：
   "这是这个人发布的"

   不能验证：
   "这个人的代码安全"
   ```

3. **信任传递**
   ```
   你信任 A 发布包 foo
   但 A 的密钥也能签署包 bar
   如何限制信任范围？
   ```

---

## 深层洞察

### 洞察1：密码学 ≠ 安全

**误解**：
```
加密 = 安全
签名 = 安全
复杂的密码学 = 更安全
```

**现实**：
```
密码学只是工具
工具需要正确的使用场景
使用场景需要信任模型
信任模型是社会问题，不是技术问题
```

### 洞察2：工具培训用户行为

**SSH 警告的例子**：
```
第一次：用户仔细看警告
第二次：用户快速浏览
第十次：用户自动按 Y
第一百次：用户甚至没看就按 Y
```

**包管理器的风险**：
```
如果频繁提示密钥变更：
↓
用户学会总是点"接受"
↓
真正的攻击发生时
↓
用户照样点"接受"
```

**作者的警告**：
```
训练用户忽略安全警告
比没有警告更危险
```

### 洞察3：中心化是不可避免的？

**去中心化的理想**：
```
Web of Trust = 去中心化信任
听起来很美好
```

**现实**：
```
包名的所有权：中心化（仓库决定）
↓
即使信任是去中心化的
↓
仍需要中心化权威说"谁拥有这个名字"
```

**可能的出路**：
```
内容寻址：
- 通过内容哈希而非名字引用包
- IPFS 模式
- 但用户体验困难
```

---

## 实用建议（尽管不完美）

### 多层防御

**不要依赖单一机制**：

```
层1：签名验证
  ↓ 过滤明显的篡改
层2：来源验证
  ↓ 检查是否来自可信仓库
层3：代码审查
  ↓ 人工检查关键代码
层4：沙箱执行
  ↓ 限制代码能做什么
层5：监控行为
  ↓ 检测异常行为
```

### 针对不同场景

**个人项目**：
```
✓ 锁定版本（lock 文件）
✓ 定期审计依赖
✓ 关注安全公告
✗ 不要盲目信任签名
```

**企业环境**：
```
✓ 内部仓库镜像
✓ 供应商审核流程
✓ 签名 + 内部批准
✓ 自动化扫描 + 人工审查
```

**开源维护者**：
```
✓ 启用 2FA
✓ 签名发布（虽然不完美）
✓ 文档化预期的发布密钥
✓ 审计贡献者权限
```

### 意识到局限

**重要**：
```
签名是有用的 ✓
签名不是万能��� ✓
签名不能替代：
- 代码审查
- 安全测试
- 依赖审计
- 最小权限原则
```

---

## 2013 vs 2025

### 这篇文章仍然相关吗？

**是的，因为**：

1. **基本问题未解决**
   ```
   2013: 没有好的信任模型
   2025: 仍然没有好的信任模型
   ```

2. **新攻击证明了观点**
   ```
   2018: event-stream
   2021: ua-parser-js
   2021: 依赖混淆攻击

   这些攻击中签名都无法阻止
   ```

3. **新技术也有同样问题**
   ```
   Cargo（Rust）：有签名能力，同样的信任问题
   npm：添加了签名，同样的信任问题
   ```

### 有什么新进展？

**一些改进**：

1. **Sigstore/Cosign**
   ```
   无密钥签名（keyless signing）
   OIDC 认证

   但仍然需要信任：
   - OIDC 提供商
   - Sigstore 基础设施
   ```

2. **软件物料清单 (SBOM)**
   ```
   记录所有依赖
   更好的透明度

   但不解决：
   - 信任问题
   - 安全性验证
   ```

3. **Reproducible Builds**
   ```
   验证构建过程
   不同人构建相同结果

   但不解决：
   - 源代码是否恶意
   ```

**核心问题仍在**：
```
2013: 我们信任什么？
2025: 我们仍在问同样的问题
```

---

## 结论

### 作者的核心论点（仍然有效）

1. **签名生成很容易**
   - 这不是问题

2. **信任模型很难**
   - 这才是真正的问题

3. **签名只能验证真实性，不能验证安全性**
   - "这确实是 Bob 发布的"
   - ≠ "Bob 的代码是安全的"

4. **最终必须信任某个权威**
   - PyPI 说谁拥有包名
   - 即使有完美的签名系统

### 金句

> "如果你没有明确定义的信任模型，你所做的只是向问题扔密码学。"

> "如果你信任仓库给你签名密钥，你什么也没获得，只是引入了复杂性。"

> "任何这些系统能够验证的唯一事情是：你获取的包是你想要的包，仅此而已。"

> "我的最大希望是，我们会得到一个终端用户与信任源有关系的解决方案，而不是包作者。"

### 实用建议

**对于开发者**：
```
✓ 使用签名（当可用时）
✓ 但不要只依赖签名
✓ 审计你的依赖
✓ 使用多层防御
✓ 意识到局限性
```

**对于工具开发者**：
```
✓ 实现签名验证
✓ 但诚实告知局限
✓ 不要让用户产生虚假安全感
✓ 探索更好的信任模型
✓ 教育用户风险
```

**对于所有人**：
```
✓ 理解签名不是圣杯
✓ 安全是系统工程，不是单一技术
✓ 保持怀疑和警惕
```

---

## 延伸思考

### 问题：有没有完美的解决方案？

**答案**：可能没有。

**因为**：
```
技术可以解决：
✓ 数据完整性
✓ 身份验证
✓ 加密通信

技术无法解决：
✗ 谁应该被信任
✗ 代码是否恶意
✗ 人的意图

这些是社会问题，不是技术问题
```

### 我们能做的最好是什么？

**现实主义的目标**：
```
不是：
"完美的安全"

而是：
"多层防御，提高攻击成本"
```

**组合策略**：
```
签名（验证完整性）
+ 审计（人工检查）
+ 监控（检测异常）
+ 最小权限（限制损害）
+ 快速响应（减少暴露时间）
= 实用的安全姿态
```

---

**总结完成**：进阶理解文档全部创建完成！查看 [README.md](./README.md) 获取完整导航。
