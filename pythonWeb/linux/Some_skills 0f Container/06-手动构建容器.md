# 06 - 手动构建容器

> 从零开始手动构建完整容器:综合运用 Namespace、Cgroups、UnionFS 和网络

## 目录

- [容器的本质](#容器的本质)
- [准备 rootfs](#准备-rootfs)
- [基础容器构建](#基础容器构建)
- [添加资源限制](#添加资源限制)
- [配置网络](#配置网络)
- [完整容器实现](#完整容器实现)
- [Python 实现容器](#python-实现容器)
- [实战案例](#实战案例)

---

## 容器的本质

【本文档是容器技术学习系列的第 06 篇】

### 容器 = 进程 + 隔离 + 限制 + 文件系统

```
┌─────────────────────────────────────────┐
│              容器                        │
│  ┌────────────────────────────────────┐ │
│  │  进程 (应用程序)                   │ │
│  └────────────────────────────────────┘ │
│            ↓                             │
│  ┌────────────────────────────────────┐ │
│  │  Namespace (隔离视图)              │ │
│  │  - PID: 独立进程树                │ │
│  │  - NET: 独立网络栈                │ │
│  │  - MNT: 独立挂载点                │ │
│  │  - UTS: 独立主机名                │ │
│  │  - IPC: 独立进程通信              │ │
│  │  - USER: 独立用户权限             │ │
│  └────────────────────────────────────┘ │
│            ↓                             │
│  ┌────────────────────────────────────┐ │
│  │  Cgroups (资源限制)                │ │
│  │  - CPU: 2核                        │ │
│  │  - 内存: 512MB                     │ │
│  │  - 磁盘 I/O: 100MB/s               │ │
│  └────────────────────────────────────┘ │
│            ↓                             │
│  ┌────────────────────────────────────┐ │
│  │  rootfs (文件系统)                 │ │
│  │  - UnionFS 分层                    │ │
│  │  - /bin, /lib, /etc...             │ │
│  └────────────────────────────────────┘ │
└─────────────────────────────────────────┘
```

### 构建容器的步骤

```
1. 准备 rootfs
   └─ 下载基础系统或使用已有镜像

2. 创建 Namespace
   └─ unshare --pid --net --mount --uts --ipc

3. 配置 rootfs
   └─ chroot 或 pivot_root

4. 配置 Cgroups
   └─ 设置资源限制

5. 配置网络
   └─ veth pair + bridge + iptables

6. 启动进程
   └─ exec 执行应用程序
```

---

## 准备 rootfs

### 方法 1: 使用 debootstrap (Debian/Ubuntu)

```bash
# 1. 安装 debootstrap
sudo apt install -y debootstrap

# 2. 创建 rootfs 目录
mkdir -p /tmp/container-rootfs

# 3. 下载最小化系统
sudo debootstrap --arch=amd64 focal /tmp/container-rootfs http://archive.ubuntu.com/ubuntu/

# 等待下载完成...
# I: Base system installed successfully.

# 4. 查看生成的文件系统
ls -la /tmp/container-rootfs/
# bin/  boot/  dev/  etc/  home/  lib/  media/  mnt/  opt/  proc/  root/  run/  sbin/  srv/  sys/  tmp/  usr/  var/

# 5. 查看大小
du -sh /tmp/container-rootfs/
# ~300MB
```

### 方法 2: 从 Docker 镜像导出

```bash
# 1. 拉取镜像
docker pull alpine:latest

# 2. 创建临时容器
docker create --name temp alpine

# 3. 导出文件系统
mkdir -p /tmp/alpine-rootfs
docker export temp | tar -C /tmp/alpine-rootfs -xf -

# 4. 清理临时容器
docker rm temp

# 5. 查看
ls -la /tmp/alpine-rootfs/
# bin/  dev/  etc/  home/  lib/  media/  mnt/  opt/  proc/  root/  run/  sbin/  srv/  sys/  tmp/  usr/  var/

du -sh /tmp/alpine-rootfs/
# ~5MB (Alpine 非常小)
```

### 方法 3: 手动构建最小 rootfs

```bash
#!/bin/bash
# build_minimal_rootfs.sh

ROOTFS="/tmp/minimal-rootfs"

# 1. 创建基本目录结构
mkdir -p $ROOTFS/{bin,lib,lib64,etc,proc,sys,dev,tmp,usr/{bin,lib}}

# 2. 复制 bash
cp /bin/bash $ROOTFS/bin/

# 3. 复制 bash 依赖的库
ldd /bin/bash | grep -o '/lib.*\.[0-9]' | while read lib; do
    cp "$lib" "$ROOTFS/$lib"
done

# 4. 复制常用命令
for cmd in ls cat echo mkdir rm; do
    cp /bin/$cmd $ROOTFS/bin/
    ldd /bin/$cmd | grep -o '/lib.*\.[0-9]' | while read lib; do
        cp "$lib" "$ROOTFS/$lib" 2>/dev/null
    done
done

# 5. 创建设备文件
sudo mknod -m 666 $ROOTFS/dev/null c 1 3
sudo mknod -m 666 $ROOTFS/dev/zero c 1 5
sudo mknod -m 666 $ROOTFS/dev/random c 1 8

# 6. 创建基本配置
echo "root:x:0:0:root:/root:/bin/bash" > $ROOTFS/etc/passwd
echo "root:x:0:" > $ROOTFS/etc/group

echo "完成!最小 rootfs 已创建: $ROOTFS"
du -sh $ROOTFS
```

---

## 基础容器构建

### 实验 1: 最简单的容器

```bash
# 1. 准备 rootfs (使用上面的 alpine)
ROOTFS="/tmp/alpine-rootfs"

# 2. 使用 unshare 创建隔离环境
sudo unshare --pid --fork --mount-proc bash

# 现在在新的 PID namespace 中

# 3. 查看进程
ps aux
# 只能看到当前 bash 进程

# 4. 切换根文件系统
chroot $ROOTFS /bin/sh

# 5. 你现在在一个"容器"中了!
hostname
cat /etc/os-release
```

### 实验 2: 完整隔离的容器

```bash
#!/bin/bash
# simple_container.sh

ROOTFS="/tmp/alpine-rootfs"
CONTAINER_NAME="my-container"

echo "=== 启动容器: $CONTAINER_NAME ==="

# 1. 创建完全隔离的环境
sudo unshare \
  --pid --fork \           # 隔离 PID
  --mount \                # 隔离挂载点
  --uts \                  # 隔离主机名
  --ipc \                  # 隔离进程间通信
  bash -c "
    # 2. 设置主机名
    hostname $CONTAINER_NAME

    # 3. 挂载 proc 和 sys
    mount -t proc proc $ROOTFS/proc
    mount -t sysfs sys $ROOTFS/sys
    mount -t tmpfs tmpfs $ROOTFS/tmp

    # 4. 切换根文件系统
    cd $ROOTFS
    pivot_root . old_root

    # 5. 卸载旧的根文件系统
    umount -l /old_root
    rmdir /old_root

    # 6. 启动 shell
    exec /bin/sh
"

echo "=== 容器已退出 ==="
```

运行:
```bash
chmod +x simple_container.sh
./simple_container.sh

# 在容器内:
/ # hostname
my-container

/ # ps aux
PID   USER     TIME  COMMAND
    1 root      0:00 /bin/sh

/ # mount | grep proc
proc on /proc type proc (rw,relatime)

/ # exit
```

---

## 添加资源限制

### 为容器添加 Cgroups 限制

```bash
#!/bin/bash
# container_with_cgroups.sh

ROOTFS="/tmp/alpine-rootfs"
CONTAINER_NAME="limited-container"
CGROUP_NAME="my-container"

echo "=== 创建 Cgroups ==="

# 1. 创建 CPU cgroup
sudo mkdir -p /sys/fs/cgroup/cpu/$CGROUP_NAME
# 限制为 0.5 核
echo 50000 | sudo tee /sys/fs/cgroup/cpu/$CGROUP_NAME/cpu.cfs_quota_us

# 2. 创建内存 cgroup
sudo mkdir -p /sys/fs/cgroup/memory/$CGROUP_NAME
# 限制为 256MB
echo 268435456 | sudo tee /sys/fs/cgroup/memory/$CGROUP_NAME/memory.limit_in_bytes

# 3. 启动容器并加入 cgroups
sudo unshare --pid --fork --mount --uts --ipc bash -c "
    # 将当前 shell 加入 cgroup
    echo \$\$ | sudo tee /sys/fs/cgroup/cpu/$CGROUP_NAME/cgroup.procs
    echo \$\$ | sudo tee /sys/fs/cgroup/memory/$CGROUP_NAME/cgroup.procs

    hostname $CONTAINER_NAME
    mount -t proc proc $ROOTFS/proc
    mount -t sysfs sys $ROOTFS/sys

    # 切换根并启动
    chroot $ROOTFS /bin/sh -c '
        echo \"容器启动,资源限制:\"
        echo \"CPU: 0.5 核\"
        echo \"内存: 256MB\"
        echo \"\"
        echo \"测试 CPU 限制:\"
        # 运行 CPU 密集任务
        dd if=/dev/zero of=/dev/null &
        PID=\$!
        sleep 3
        kill \$PID
        echo \"\"
        /bin/sh
    '
"

# 4. 清理 cgroups
sudo rmdir /sys/fs/cgroup/cpu/$CGROUP_NAME 2>/dev/null
sudo rmdir /sys/fs/cgroup/memory/$CGROUP_NAME 2>/dev/null

echo "=== 容器已停止 ==="
```

### 验证资源限制

```bash
# 在宿主机另一个终端监控

# 1. 查看容器进程的 CPU 使用率
top -p $(pgrep -f $CGROUP_NAME)
# CPU 使用率应该被限制在 50% 左右

# 2. 查看内存使用
cat /sys/fs/cgroup/memory/$CGROUP_NAME/memory.usage_in_bytes
cat /sys/fs/cgroup/memory/$CGROUP_NAME/memory.limit_in_bytes
```

---

## 配置网络

### 为容器配置独立网络

```bash
#!/bin/bash
# container_with_network.sh

ROOTFS="/tmp/alpine-rootfs"
CONTAINER_NAME="net-container"
BRIDGE="container-br0"
VETH_HOST="veth-host"
VETH_CONTAINER="veth-cont"
CONTAINER_IP="10.200.1.10/24"
BRIDGE_IP="10.200.1.1/24"

echo "=== 配置网络 ==="

# 1. 创建网桥
sudo ip link add $BRIDGE type bridge 2>/dev/null
sudo ip addr add $BRIDGE_IP dev $BRIDGE 2>/dev/null
sudo ip link set $BRIDGE up

# 2. 启用 IP 转发
sudo sysctl -w net.ipv4.ip_forward=1

# 3. 配置 NAT
sudo iptables -t nat -A POSTROUTING -s 10.200.1.0/24 ! -o $BRIDGE -j MASQUERADE 2>/dev/null

echo "=== 启动容器 ==="

# 4. 启动容器 (包含网络 namespace)
sudo unshare --pid --fork --mount --uts --ipc --net bash -c "
    # 在新的网络 namespace 中

    # 5. 创建 veth pair (在宿主机执行)
    nsenter -t 1 -n ip link add $VETH_HOST type veth peer name $VETH_CONTAINER

    # 6. 将 veth 一端移到容器
    CONTAINER_PID=\$\$
    nsenter -t 1 -n ip link set $VETH_CONTAINER netns \$CONTAINER_PID

    # 7. 配置容器内的网络
    ip link set lo up
    ip link set $VETH_CONTAINER name eth0
    ip addr add $CONTAINER_IP dev eth0
    ip link set eth0 up
    ip route add default via 10.200.1.1

    # 8. 在宿主机端配置 (通过 nsenter)
    nsenter -t 1 -n bash << 'EOF'
        ip link set $VETH_HOST master $BRIDGE
        ip link set $VETH_HOST up
EOF

    # 9. 设置 hostname 和挂载
    hostname $CONTAINER_NAME
    mount -t proc proc $ROOTFS/proc
    mount -t sysfs sys $ROOTFS/sys

    # 10. 配置 DNS
    mkdir -p $ROOTFS/etc
    echo 'nameserver 8.8.8.8' > $ROOTFS/etc/resolv.conf

    # 11. 启动容器
    chroot $ROOTFS /bin/sh -c '
        echo \"容器网络配置:\"
        ip addr show eth0
        echo \"\"
        echo \"测试网络连通性:\"
        ping -c 3 8.8.8.8
        echo \"\"
        /bin/sh
    '
"

echo "=== 清理网络 ==="
sudo ip link del $VETH_HOST 2>/dev/null
# sudo ip link del $BRIDGE 2>/dev/null  # 保留网桥供其他容器使用

echo "=== 容器已停止 ==="
```

---

## 完整容器实现

### 功能完整的容器脚本

```bash
#!/bin/bash
# full_container.sh - 完整的容器实现

set -e

# 配置
ROOTFS="${1:-/tmp/alpine-rootfs}"
CONTAINER_NAME="${2:-my-container}"
CPU_LIMIT="${3:-50000}"        # 50% 的 CPU
MEM_LIMIT="${4:-268435456}"    # 256MB
CONTAINER_IP="10.200.1.$((RANDOM % 200 + 10))"

CGROUP_NAME="container-$CONTAINER_NAME"
BRIDGE="container-br0"
VETH_HOST="veth-$(echo $CONTAINER_NAME | cut -c1-8)"
VETH_CONTAINER="eth0"

# 颜色输出
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log() {
    echo -e "${GREEN}[$(date +'%H:%M:%S')]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# 清理函数
cleanup() {
    log "清理资源..."
    sudo ip link del $VETH_HOST 2>/dev/null || true
    sudo rmdir /sys/fs/cgroup/cpu/$CGROUP_NAME 2>/dev/null || true
    sudo rmdir /sys/fs/cgroup/memory/$CGROUP_NAME 2>/dev/null || true
}

trap cleanup EXIT

# 检查 rootfs
if [ ! -d "$ROOTFS" ]; then
    warn "rootfs 不存在: $ROOTFS"
    exit 1
fi

log "=== 启动容器: $CONTAINER_NAME ==="
log "rootfs: $ROOTFS"
log "CPU 限制: $(echo "scale=2; $CPU_LIMIT / 100000" | bc) 核"
log "内存限制: $((MEM_LIMIT / 1024 / 1024)) MB"
log "容器 IP: $CONTAINER_IP/24"

# 1. 配置网桥
log "配置网桥..."
if ! ip link show $BRIDGE &>/dev/null; then
    sudo ip link add $BRIDGE type bridge
    sudo ip addr add 10.200.1.1/24 dev $BRIDGE
    sudo ip link set $BRIDGE up
fi

# 2. 配置 NAT
log "配置 NAT..."
sudo sysctl -w net.ipv4.ip_forward=1 >/dev/null
sudo iptables -t nat -C POSTROUTING -s 10.200.1.0/24 ! -o $BRIDGE -j MASQUERADE 2>/dev/null || \
    sudo iptables -t nat -A POSTROUTING -s 10.200.1.0/24 ! -o $BRIDGE -j MASQUERADE

# 3. 创建 Cgroups
log "创建 Cgroups..."
sudo mkdir -p /sys/fs/cgroup/cpu/$CGROUP_NAME
sudo mkdir -p /sys/fs/cgroup/memory/$CGROUP_NAME
echo $CPU_LIMIT | sudo tee /sys/fs/cgroup/cpu/$CGROUP_NAME/cpu.cfs_quota_us >/dev/null
echo $MEM_LIMIT | sudo tee /sys/fs/cgroup/memory/$CGROUP_NAME/memory.limit_in_bytes >/dev/null

# 4. 启动容器
log "启动容器进程..."

sudo unshare --pid --fork --mount --uts --ipc --net bash -c "
    set -e

    # 将进程加入 cgroups
    echo \$\$ | sudo tee /sys/fs/cgroup/cpu/$CGROUP_NAME/cgroup.procs >/dev/null
    echo \$\$ | sudo tee /sys/fs/cgroup/memory/$CGROUP_NAME/cgroup.procs >/dev/null

    # 配置网络
    CONTAINER_PID=\$\$

    # 在宿主机 namespace 中创建 veth pair
    nsenter -t 1 -n ip link add $VETH_HOST type veth peer name temp-veth
    nsenter -t 1 -n ip link set temp-veth netns \$CONTAINER_PID

    # 在容器中配置网络
    ip link set lo up
    ip link set temp-veth name $VETH_CONTAINER
    ip addr add $CONTAINER_IP/24 dev $VETH_CONTAINER
    ip link set $VETH_CONTAINER up
    ip route add default via 10.200.1.1

    # 在宿主机中连接 veth 到网桥
    nsenter -t 1 -n ip link set $VETH_HOST master $BRIDGE
    nsenter -t 1 -n ip link set $VETH_HOST up

    # 设置主机名
    hostname $CONTAINER_NAME

    # 挂载文件系统
    mount -t proc proc $ROOTFS/proc 2>/dev/null || true
    mount -t sysfs sys $ROOTFS/sys 2>/dev/null || true
    mount -t tmpfs tmpfs $ROOTFS/tmp 2>/dev/null || true

    # 配置 DNS
    mkdir -p $ROOTFS/etc
    echo 'nameserver 8.8.8.8' > $ROOTFS/etc/resolv.conf

    # 切换根文件系统并启动
    cd $ROOTFS

    chroot . /bin/sh -c '
        clear
        echo \"=====================================\"
        echo \"  欢迎来到容器: $CONTAINER_NAME\"
        echo \"=====================================\"
        echo \"\"
        echo \"容器信息:\"
        echo \"  主机名: \$(hostname)\"
        echo \"  IP 地址: $CONTAINER_IP\"
        echo \"  CPU 限制: $(echo "scale=2; $CPU_LIMIT / 100000" | bc) 核\"
        echo \"  内存限制: $((MEM_LIMIT / 1024 / 1024)) MB\"
        echo \"\"
        echo \"可用命令:\"
        echo \"  ip addr       - 查看网络配置\"
        echo \"  ping 8.8.8.8  - 测试网络连通性\"
        echo \"  top           - 查看进程 (如果可用)\"
        echo \"  exit          - 退出容器\"
        echo \"\"
        exec /bin/sh
    '
"

log "=== 容器已停止 ==="
```

### 使用方法

```bash
# 1. 准备 rootfs
docker export $(docker create alpine) | tar -C /tmp/alpine-rootfs -xf -

# 2. 运行容器
chmod +x full_container.sh
sudo ./full_container.sh /tmp/alpine-rootfs my-app

# 3. 在容器内测试
hostname          # my-app
ip addr           # 10.200.1.x
ping -c 3 8.8.8.8 # 网络畅通
ps aux            # 只能看到容器内进程

# 4. 退出
exit
```

---

## Python 实现容器

### 使用 Python 创建简单容器

```python
#!/usr/bin/env python3
# simple_container.py

import os
import sys
import subprocess
import ctypes
import argparse

# Linux namespace 常量
CLONE_NEWNS = 0x00020000    # Mount namespace
CLONE_NEWUTS = 0x04000000   # UTS namespace
CLONE_NEWIPC = 0x08000000   # IPC namespace
CLONE_NEWPID = 0x20000000   # PID namespace
CLONE_NEWNET = 0x40000000   # Network namespace

# 加载 libc
libc = ctypes.CDLL('libc.so.6', use_errno=True)

def create_container(rootfs, command):
    """创建并运行容器"""

    print(f"[*] 创建容器: {command}")
    print(f"[*] rootfs: {rootfs}")

    # 1. Fork 新进程
    pid = os.fork()

    if pid == 0:
        # 子进程
        try:
            # 2. Unshare 创建新的 namespace
            flags = CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNET
            ret = libc.unshare(flags)
            if ret != 0:
                print(f"[!] unshare 失败: {ctypes.get_errno()}", file=sys.stderr)
                sys.exit(1)

            # 3. 挂载 proc
            os.makedirs(f"{rootfs}/proc", exist_ok=True)
            subprocess.run(['mount', '-t', 'proc', 'proc', f'{rootfs}/proc'], check=True)

            # 4. 切换根文件系统
            os.chroot(rootfs)
            os.chdir('/')

            # 5. 设置主机名
            libc.sethostname(b'my-container', len(b'my-container'))

            # 6. 执行命令
            os.execvp(command[0], command)

        except Exception as e:
            print(f"[!] 容器启动失败: {e}", file=sys.stderr)
            sys.exit(1)

    else:
        # 父进程
        print(f"[*] 容器 PID: {pid}")
        _, status = os.waitpid(pid, 0)
        print(f"[*] 容器退出,状态: {status}")

def main():
    parser = argparse.ArgumentParser(description='简单容器实现')
    parser.add_argument('rootfs', help='rootfs 路径')
    parser.add_argument('command', nargs='*', default=['/bin/sh'], help='要执行的命令')

    args = parser.parse_args()

    if os.geteuid() != 0:
        print("[!] 需要 root 权限", file=sys.stderr)
        sys.exit(1)

    if not os.path.isdir(args.rootfs):
        print(f"[!] rootfs 不存在: {args.rootfs}", file=sys.stderr)
        sys.exit(1)

    create_container(args.rootfs, args.command)

if __name__ == '__main__':
    main()
```

### 增强版 Python 容器

```python
#!/usr/bin/env python3
# advanced_container.py

import os
import sys
import subprocess
import ctypes
import argparse
import uuid

CLONE_NEWNS = 0x00020000
CLONE_NEWUTS = 0x04000000
CLONE_NEWIPC = 0x08000000
CLONE_NEWPID = 0x20000000
CLONE_NEWNET = 0x40000000

libc = ctypes.CDLL('libc.so.6', use_errno=True)

class Container:
    def __init__(self, rootfs, name=None, cpu_limit=None, mem_limit=None):
        self.rootfs = rootfs
        self.name = name or f"container-{uuid.uuid4().hex[:8]}"
        self.cpu_limit = cpu_limit  # 0.5 = 50%
        self.mem_limit = mem_limit  # bytes
        self.cgroup_name = f"py-{self.name}"

    def setup_cgroups(self, pid):
        """设置 cgroups 限制"""
        if self.cpu_limit:
            # CPU 限制
            cgroup_path = f"/sys/fs/cgroup/cpu/{self.cgroup_name}"
            os.makedirs(cgroup_path, exist_ok=True)

            quota = int(self.cpu_limit * 100000)
            with open(f"{cgroup_path}/cpu.cfs_quota_us", 'w') as f:
                f.write(str(quota))

            with open(f"{cgroup_path}/cgroup.procs", 'w') as f:
                f.write(str(pid))

            print(f"[*] CPU 限制: {self.cpu_limit} 核")

        if self.mem_limit:
            # 内存限制
            cgroup_path = f"/sys/fs/cgroup/memory/{self.cgroup_name}"
            os.makedirs(cgroup_path, exist_ok=True)

            with open(f"{cgroup_path}/memory.limit_in_bytes", 'w') as f:
                f.write(str(self.mem_limit))

            with open(f"{cgroup_path}/cgroup.procs", 'w') as f:
                f.write(str(pid))

            print(f"[*] 内存限制: {self.mem_limit // 1024 // 1024} MB")

    def cleanup_cgroups(self):
        """清理 cgroups"""
        for subsystem in ['cpu', 'memory']:
            cgroup_path = f"/sys/fs/cgroup/{subsystem}/{self.cgroup_name}"
            try:
                os.rmdir(cgroup_path)
            except:
                pass

    def child_process(self, command):
        """容器子进程"""
        try:
            # 1. Unshare namespaces
            flags = CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNET
            libc.unshare(flags)

            # 2. 挂载 proc、sys、tmp
            os.makedirs(f"{self.rootfs}/proc", exist_ok=True)
            os.makedirs(f"{self.rootfs}/sys", exist_ok=True)
            os.makedirs(f"{self.rootfs}/tmp", exist_ok=True)

            subprocess.run(['mount', '-t', 'proc', 'proc', f'{self.rootfs}/proc'],
                          stderr=subprocess.DEVNULL)
            subprocess.run(['mount', '-t', 'sysfs', 'sys', f'{self.rootfs}/sys'],
                          stderr=subprocess.DEVNULL)
            subprocess.run(['mount', '-t', 'tmpfs', 'tmpfs', f'{self.rootfs}/tmp'],
                          stderr=subprocess.DEVNULL)

            # 3. 切换根
            os.chroot(self.rootfs)
            os.chdir('/')

            # 4. 设置主机名
            libc.sethostname(self.name.encode(), len(self.name))

            # 5. 打印欢迎信息
            print("=" * 50)
            print(f"  容器: {self.name}")
            print("=" * 50)
            print()

            # 6. 执行命令
            os.execvp(command[0], command)

        except Exception as e:
            print(f"[!] 错误: {e}", file=sys.stderr)
            sys.exit(1)

    def run(self, command):
        """运行容器"""
        print(f"[*] 启动容器: {self.name}")
        print(f"[*] rootfs: {self.rootfs}")

        # Fork
        pid = os.fork()

        if pid == 0:
            # 子进程
            self.child_process(command)
        else:
            # 父进程
            print(f"[*] 容器 PID: {pid}")

            # 设置 cgroups
            self.setup_cgroups(pid)

            # 等待容器退出
            try:
                _, status = os.waitpid(pid, 0)
                print(f"\n[*] 容器退出,状态: {status}")
            finally:
                self.cleanup_cgroups()

def main():
    parser = argparse.ArgumentParser(description='Python 容器实现')
    parser.add_argument('rootfs', help='rootfs 路径')
    parser.add_argument('--name', help='容器名称')
    parser.add_argument('--cpu', type=float, help='CPU 限制 (核心数,如 0.5)')
    parser.add_argument('--memory', type=int, help='内存限制 (MB)')
    parser.add_argument('command', nargs='*', default=['/bin/sh'], help='命令')

    args = parser.parse_args()

    if os.geteuid() != 0:
        print("[!] 需要 root 权限", file=sys.stderr)
        sys.exit(1)

    mem_bytes = args.memory * 1024 * 1024 if args.memory else None

    container = Container(
        rootfs=args.rootfs,
        name=args.name,
        cpu_limit=args.cpu,
        mem_limit=mem_bytes
    )

    container.run(args.command)

if __name__ == '__main__':
    main()
```

### 使用 Python 容器

```bash
# 1. 基础用法
sudo python3 simple_container.py /tmp/alpine-rootfs

# 2. 高级用法 - 带资源限制
sudo python3 advanced_container.py \
    --name my-app \
    --cpu 0.5 \
    --memory 256 \
    /tmp/alpine-rootfs \
    /bin/sh

# 3. 运行特定命令
sudo python3 advanced_container.py \
    /tmp/alpine-rootfs \
    /bin/sh -c "echo Hello from container!"
```

---

## 实战案例

### 案例 1: 运行 Web 服务器

```bash
#!/bin/bash
# web_container.sh

ROOTFS="/tmp/alpine-rootfs"

# 1. 在 rootfs 中准备 Web 服务
cat > $ROOTFS/app.py << 'EOF'
from http.server import HTTPServer, BaseHTTPRequestHandler
import os

class Handler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.end_headers()
        html = f"""
        <html>
        <body>
            <h1>Hello from Container!</h1>
            <p>Hostname: {os.uname().nodename}</p>
            <p>PID: {os.getpid()}</p>
        </body>
        </html>
        """
        self.wfile.write(html.encode())

HTTPServer(('0.0.0.0', 8080), Handler).serve_forever()
EOF

# 2. 启动容器并运行 Web 服务
sudo python3 advanced_container.py \
    --name web-server \
    --cpu 1.0 \
    --memory 128 \
    $ROOTFS \
    python3 /app.py &

CONTAINER_PID=$!

# 3. 配置端口映射 (DNAT)
sleep 2
CONTAINER_IP=$(sudo ip netns exec $CONTAINER_PID ip addr show eth0 | grep inet | awk '{print $2}' | cut -d/ -f1)

sudo iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination $CONTAINER_IP:8080
sudo iptables -t nat -A OUTPUT -p tcp --dport 8080 -j DNAT --to-destination $CONTAINER_IP:8080

echo "Web 服务器运行在: http://localhost:8080"
echo "按 Ctrl+C 停止"

wait $CONTAINER_PID
```

### 案例 2: 容器编排

```bash
#!/bin/bash
# multi_containers.sh - 运行多个容器

ROOTFS="/tmp/alpine-rootfs"

# 启动 3 个容器
for i in 1 2 3; do
    sudo python3 advanced_container.py \
        --name app-$i \
        --cpu 0.3 \
        --memory 128 \
        $ROOTFS \
        /bin/sh -c "echo 'Container $i' && sleep 10" &

    echo "启动容器 app-$i"
    sleep 1
done

echo "等待所有容器完成..."
wait

echo "所有容器已停止"
```

---

## 常见问题

### Q1: 为什么需要 pivot_root 而不是 chroot?

**chroot** 的问题:
- 不会改变当前工作目录
- 旧根仍然可以访问
- 安全性较弱

**pivot_root** 的优势:
- 完全切换根文件系统
- 卸载旧根
- 更安全

### Q2: 容器无法访问网络?

检查:
```bash
# 1. 检查 IP 转发
sysctl net.ipv4.ip_forward

# 2. 检查 NAT 规则
sudo iptables -t nat -L -n

# 3. 检查容器内路由
ip netns exec <container-pid> ip route
```

### Q3: 资源限制不生效?

```bash
# 验证 cgroups 挂载
mount | grep cgroup

# 检查进程是否在 cgroup 中
cat /sys/fs/cgroup/cpu/<cgroup-name>/cgroup.procs
```

---

## 总结

### 核心步骤

```
1. 准备 rootfs
2. 创建 Namespace (隔离)
3. 配置 Cgroups (限制)
4. 设置网络 (通信)
5. 切换根文件系统
6. 启动进程
```

### 容器 vs Docker

| 特性           | 手动容器       | Docker              |
|---------------|---------------|---------------------|
| **基础原理**   | 相同          | 相同                |
| **易用性**     | 复杂          | 简单                |
| **镜像管理**   | 手动          | 自动化              |
| **网络配置**   | 手动          | 自动化              |
| **安全性**     | 依赖实现      | 内置安全特性        |
| **生态系统**   | 无            | 丰富 (Hub, Compose) |

### 关键技术

1. **Namespace** - `unshare` 命令创建隔离
2. **Cgroups** - `/sys/fs/cgroup` 目录配置限制
3. **rootfs** - 完整的文件系统目录树
4. **网络** - veth pair + bridge
5. **挂载** - `mount proc/sys/tmp`

### 下一步

学习 [07-容器运行时](./07-容器运行时.md) - 了解 OCI、runc 和 containerd!

---

## 参考资源

- [Linux Namespaces](https://man7.org/linux/man-pages/man7/namespaces.7.html)
- [Linux Cgroups](https://www.kernel.org/doc/Documentation/cgroup-v1/)
- [Building Containers from Scratch](https://www.youtube.com/watch?v=8fi7uSYlOdc)
- [Container Training](https://container.training/)

---

*更新日期: 2025-12-03*
*作者: Claude Code*
