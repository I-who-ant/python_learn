# 05 - 容器网络详解

> 深入理解容器网络：veth pair、bridge、iptables、路由和 NAT

## 目录

- [容器网络基础](#容器网络基础)
- [veth pair 详解](#veth-pair-详解)
- [Linux Bridge 网桥](#linux-bridge-网桥)
- [iptables 和 NAT](#iptables-和-nat)
- [容器网络模型](#容器网络模型)
- [Docker 网络实现](#docker-网络实现)
- [跨主机网络](#跨主机网络)
- [实战案例](#实战案例)

---

## 容器网络基础

### 容器网络需要解决的问题

1. **容器内部隔离** - 每个容器有独立的网络栈
2. **容器间通信** - 同主机容器互相访问
3. **容器访问外网** - 容器访问互联网
4. **外网访问容器** - 外部访问容器服务

### 网络架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    宿主机 (Host)                             │
│                                                              │
│  ┌──────────┐         ┌──────────┐         ┌──────────┐   │
│  │ 容器 A    │         │ 容器 B    │         │ 容器 C    │   │
│  │          │         │          │         │          │   │
│  │ eth0     │         │ eth0     │         │ eth0     │   │
│  │ 172.17.0.2│        │ 172.17.0.3│        │ 172.17.0.4│  │
│  └─────┬────┘         └─────┬────┘         └─────┬────┘   │
│        │                    │                    │         │
│      veth0a                veth0b               veth0c     │
│        │                    │                    │         │
│        └────────────────────┼────────────────────┘         │
│                             │                               │
│                        docker0 (bridge)                     │
│                        172.17.0.1/16                        │
│                             │                               │
│                          iptables                           │
│                             │                               │
│                          eth0 (物理网卡)                     │
│                          192.168.1.100                      │
└─────────────────────────────┼───────────────────────────────┘
                              │
                         互联网 (Internet)
```

---

## veth pair 详解

### 什么是 veth pair

veth (Virtual Ethernet) 是一对虚拟网卡设备，就像一根网线的两端：
- 数据从一端进入，从另一端出来
- 常用于连接不同的网络命名空间

### 创建和使用 veth pair

```bash
# 1. 创建 veth pair
sudo ip link add veth0 type veth peer name veth1

# 2. 查看创建的设备
ip link show type veth
# 输出:
# 8: veth1@veth0: <BROADCAST,MULTICAST,M-DOWN> mtu 1500
# 9: veth0@veth1: <BROADCAST,MULTICAST,M-DOWN> mtu 1500

# 3. 配置 IP 地址
sudo ip addr add 192.168.1.1/24 dev veth0
sudo ip addr add 192.168.1.2/24 dev veth1

# 4. 启动设备
sudo ip link set veth0 up
sudo ip link set veth1 up

# 5. 测试连通性
ping -c 3 -I veth0 192.168.1.2
```

### veth pair 连接命名空间

```bash
# 1. 创建网络命名空间
sudo ip netns add netns1
sudo ip netns add netns2

# 2. 创建 veth pair
sudo ip link add veth0 type veth peer name veth1

# 3. 将 veth 一端移到命名空间
sudo ip link set veth0 netns netns1
sudo ip link set veth1 netns netns2

# 4. 在各自命名空间中配置 IP
sudo ip netns exec netns1 ip addr add 10.0.0.1/24 dev veth0
sudo ip netns exec netns1 ip link set veth0 up
sudo ip netns exec netns1 ip link set lo up

sudo ip netns exec netns2 ip addr add 10.0.0.2/24 dev veth1
sudo ip netns exec netns2 ip link set veth1 up
sudo ip netns exec netns2 ip link set lo up

# 5. 测试连通性
sudo ip netns exec netns1 ping -c 3 10.0.0.2
# PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.
# 64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=0.045 ms

# 6. 清理
sudo ip netns del netns1
sudo ip netns del netns2
```

---

## Linux Bridge 网桥

### 什么是 Bridge

Linux Bridge 相当于虚拟交换机，用于连接多个网络设备：
- 工作在二层（链路层）
- 自动学习 MAC 地址
- 转发数据包

### 创建和配置网桥

```bash
# 1. 创建网桥
sudo ip link add br0 type bridge

# 2. 配置 IP 地址（网桥作为网关）
sudo ip addr add 10.0.0.1/24 dev br0

# 3. 启动网桥
sudo ip link set br0 up

# 4. 查看网桥
ip link show br0
brctl show  # 如果安装了 bridge-utils
```

### 将 veth 连接到网桥

```bash
# 1. 创建网桥
sudo ip link add docker0 type bridge
sudo ip addr add 172.17.0.1/16 dev docker0
sudo ip link set docker0 up

# 2. 创建容器网络命名空间
sudo ip netns add container1
sudo ip netns add container2

# 3. 为容器 1 创建 veth pair
sudo ip link add veth0 type veth peer name veth-c1
sudo ip link set veth-c1 netns container1

# 配置容器内网卡
sudo ip netns exec container1 ip addr add 172.17.0.2/16 dev veth-c1
sudo ip netns exec container1 ip link set veth-c1 up
sudo ip netns exec container1 ip link set lo up

# 将 veth0 连接到网桥
sudo ip link set veth0 master docker0
sudo ip link set veth0 up

# 4. 为容器 2 创建 veth pair（同样步骤）
sudo ip link add veth1 type veth peer name veth-c2
sudo ip link set veth-c2 netns container2

sudo ip netns exec container2 ip addr add 172.17.0.3/16 dev veth-c2
sudo ip netns exec container2 ip link set veth-c2 up
sudo ip netns exec container2 ip link set lo up

sudo ip link set veth1 master docker0
sudo ip link set veth1 up

# 5. 测试容器间通信
sudo ip netns exec container1 ping -c 3 172.17.0.3
# 成功！容器1可以ping通容器2

# 6. 查看网桥连接
brctl show docker0
# 或
bridge link show
```

---

## iptables 和 NAT

### 为什么需要 iptables

容器默认无法访问外网，需要通过 NAT (Network Address Translation) 将容器内网 IP 转换为宿主机 IP。

### iptables 基础

```bash
# 查看 NAT 规则
sudo iptables -t nat -L -n -v

# 查看 FILTER 规则
sudo iptables -t filter -L -n -v

# iptables 四表五链
# 表: filter(过滤), nat(地址转换), mangle(修改包), raw(状态跟踪)
# 链: INPUT, OUTPUT, FORWARD, PREROUTING, POSTROUTING
```

### 配置容器 NAT

```bash
# 1. 启用 IP 转发（必须！）
sudo sysctl -w net.ipv4.ip_forward=1

# 持久化配置
echo "net.ipv4.ip_forward=1" | sudo tee -a /etc/sysctl.conf
sudo sysctl -p

# 2. 配置 SNAT/MASQUERADE
# MASQUERADE: 自动使用出口网卡的 IP
sudo iptables -t nat -A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE

# 解释:
# -t nat: 使用 nat 表
# -A POSTROUTING: 在 POSTROUTING 链添加规则
# -s 172.17.0.0/16: 源地址是容器网段
# ! -o docker0: 出口不是 docker0 网桥
# -j MASQUERADE: 进行地址伪装（SNAT）

# 3. 允许转发
sudo iptables -A FORWARD -i docker0 -j ACCEPT
sudo iptables -A FORWARD -o docker0 -j ACCEPT

# 4. 测试容器访问外网
sudo ip netns exec container1 ip route add default via 172.17.0.1
sudo ip netns exec container1 ping -c 3 8.8.8.8
# 成功！

# 5. 配置 DNS
sudo mkdir -p /etc/netns/container1
echo "nameserver 8.8.8.8" | sudo tee /etc/netns/container1/resolv.conf
sudo ip netns exec container1 ping -c 3 google.com
```

### 端口映射（DNAT）

```bash
# 将宿主机 8080 端口映射到容器 80 端口

# 1. DNAT 规则（外部访问）
sudo iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 172.17.0.2:80

# 2. 本机访问容器（需要额外规则）
sudo iptables -t nat -A OUTPUT -p tcp --dport 8080 -j DNAT --to-destination 172.17.0.2:80

# 3. 允许转发
sudo iptables -A FORWARD -p tcp -d 172.17.0.2 --dport 80 -j ACCEPT

# 4. 测试
# 在容器内启动一个简单的 HTTP 服务
sudo ip netns exec container1 python3 -m http.server 80 &

# 从外部访问
curl http://宿主机IP:8080

# 5. 查看规则
sudo iptables -t nat -L -n -v | grep 8080
```

---

## 容器网络模型

### 1. Bridge 模式（默认）

```
容器 → veth → bridge → iptables → 外网
```

**特点**：
- 容器有独立 IP
- 通过 NAT 访问外网
- 默认模式

### 2. Host 模式

```
容器 → 宿主机网络栈（共享）
```

```bash
# Docker 示例
docker run --network host nginx

# 手动实现
# 不创建新的 network namespace��直接使用宿主机网络
unshare --pid --fork --mount /bin/bash
# 注意：没有 --net 参数
```

**特点**：
- 性能最好
- 无网络隔离
- 端口冲突风险

### 3. None 模式

```
容器 → 无网络（只有 lo）
```

```bash
# Docker 示例
docker run --network none nginx

# 手动实现
sudo unshare --net /bin/bash
ip addr show  # 只有 lo
```

**特点**：
- 完全隔离
- 需要手动配置网络

### 4. Container 模式

```
容器A → 共享 → 容器B的网络
```

```bash
# Docker 示例
docker run --name container1 -d nginx
docker run --network container:container1 alpine

# 手动实现
# 两个进程共享同一个 network namespace
sudo ip netns add shared_net
sudo ip netns exec shared_net bash &
sudo ip netns exec shared_net bash  # 共享网络
```

---

## Docker 网络实现

### Docker 网络架构

```
┌────────────────────────────────────────┐
│         Docker 网络驱动                 │
├────────────────────────────────────────┤
│  bridge  │  host  │  none  │  overlay  │
├────────────────────────────────────────┤
│           libnetwork                   │
├────────────────────────────────────────┤
│  Linux: veth, bridge, iptables, route  │
└────────────────────────────────────────┘
```

### Docker 网络命令

```bash
# 1. 查看网络
docker network ls
# bridge (默认)
# host
# none

# 2. 查看默认 bridge 详情
docker network inspect bridge

# 3. 创建自定义网络
docker network create --driver bridge \
  --subnet=172.18.0.0/16 \
  --gateway=172.18.0.1 \
  mynet

# 4. 运行容器并指定网络
docker run -d --name web --network mynet nginx

# 5. 查看容器 IP
docker inspect web | grep IPAddress

# 6. 容器间通信（服务发现）
docker run -d --name db --network mynet mysql
docker run -d --name app --network mynet \
  -e DB_HOST=db \  # 可以直接使用容器名
  myapp

# 7. 连接/断开网络
docker network connect mynet container_name
docker network disconnect mynet container_name

# 8. 端口映射
docker run -d -p 8080:80 --name web nginx
# 宿主机 8080 → 容器 80

# 9. 查看 iptables 规则
sudo iptables -t nat -L -n | grep 8080
```

### Docker 网络底层实现

```bash
# 1. 查看 Docker 创建的网桥
ip link show docker0

# 2. 查看容器的 veth pair
docker run -d --name test nginx
container_pid=$(docker inspect -f '{{.State.Pid}}' test)

# 在宿主机查看
sudo ls -l /proc/$container_pid/ns/net

# 查看容器的网络接口
sudo nsenter -t $container_pid -n ip addr show

# 3. 查看 iptables 规则
sudo iptables -t nat -L -n -v | grep docker

# 4. 查看路由
ip route show | grep docker0
```

---

## 跨主机网络

### Overlay 网络原理

```
主机A: 容器1 (10.0.1.2) → VXLAN → 主机B: 容器2 (10.0.1.3)
```

**VXLAN (Virtual Extensible LAN)**：
- 在三层网络上构建二层网络
- UDP 封装（端口 4789）
- 支持跨主机容器通信

### Flannel 示例

```bash
# 安装 Flannel
kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml

# Flannel 工作原理
# 1. 为每个节点分配子网
# Node1: 10.244.0.0/24
# Node2: 10.244.1.0/24

# 2. 创建路由规则
# Node1 上: 10.244.1.0/24 via Node2_IP

# 3. 封装方式
# - VXLAN (默认)
# - host-gw (性能好，要求二层可达)
# - UDP (老版本)
```

### Calico 示例

```bash
# Calico 使用 BGP 路由
# 不需要封装，性能更好

# 安装 Calico
kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml

# 查看 BGP 邻居
sudo calicoctl node status

# 查看路由
ip route | grep cali
```

---

## 实战案例

### 案例 1: 手动创建完整的容器网络

```bash
#!/bin/bash
# create_container_network.sh

set -e

# 配置
BRIDGE_NAME="my-bridge"
BRIDGE_IP="10.100.0.1/24"
CONTAINER1_NAME="container1"
CONTAINER1_IP="10.100.0.10/24"
CONTAINER2_NAME="container2"
CONTAINER2_IP="10.100.0.20/24"

echo "=== 创建容器网络 ==="

# 1. 创建网桥
echo "[1/6] 创建网桥 $BRIDGE_NAME"
sudo ip link add $BRIDGE_NAME type bridge
sudo ip addr add $BRIDGE_IP dev $BRIDGE_NAME
sudo ip link set $BRIDGE_NAME up

# 2. 启用 IP 转发
echo "[2/6] 启用 IP 转发"
sudo sysctl -w net.ipv4.ip_forward=1

# 3. 配置 NAT
echo "[3/6] 配置 NAT"
sudo iptables -t nat -A POSTROUTING -s 10.100.0.0/24 ! -o $BRIDGE_NAME -j MASQUERADE
sudo iptables -A FORWARD -i $BRIDGE_NAME -j ACCEPT
sudo iptables -A FORWARD -o $BRIDGE_NAME -j ACCEPT

# 4. 创建容器 1
echo "[4/6] 创建容器 1"
sudo ip netns add $CONTAINER1_NAME
sudo ip link add veth0 type veth peer name veth-c1
sudo ip link set veth-c1 netns $CONTAINER1_NAME
sudo ip link set veth0 master $BRIDGE_NAME
sudo ip link set veth0 up

sudo ip netns exec $CONTAINER1_NAME ip addr add $CONTAINER1_IP dev veth-c1
sudo ip netns exec $CONTAINER1_NAME ip link set veth-c1 up
sudo ip netns exec $CONTAINER1_NAME ip link set lo up
sudo ip netns exec $CONTAINER1_NAME ip route add default via 10.100.0.1

# 5. 创建容器 2
echo "[5/6] 创建容器 2"
sudo ip netns add $CONTAINER2_NAME
sudo ip link add veth1 type veth peer name veth-c2
sudo ip link set veth-c2 netns $CONTAINER2_NAME
sudo ip link set veth1 master $BRIDGE_NAME
sudo ip link set veth1 up

sudo ip netns exec $CONTAINER2_NAME ip addr add $CONTAINER2_IP dev veth-c2
sudo ip netns exec $CONTAINER2_NAME ip link set veth-c2 up
sudo ip netns exec $CONTAINER2_NAME ip link set lo up
sudo ip netns exec $CONTAINER2_NAME ip route add default via 10.100.0.1

# 6. 测试
echo "[6/6] 测试网络连通性"
echo "容器1 ping 容器2:"
sudo ip netns exec $CONTAINER1_NAME ping -c 3 10.100.0.20

echo "容器1 ping 外网:"
sudo ip netns exec $CONTAINER1_NAME ping -c 3 8.8.8.8

echo ""
echo "=== 网络创建成功! ==="
echo "进入容器1: sudo ip netns exec $CONTAINER1_NAME bash"
echo "进入容器2: sudo ip netns exec $CONTAINER2_NAME bash"
echo ""
echo "清理: sudo ip netns del $CONTAINER1_NAME && sudo ip netns del $CONTAINER2_NAME && sudo ip link del $BRIDGE_NAME"
```

### 案例 2: 容器端口映射

```bash
#!/bin/bash
# port_mapping.sh

# 容器运行 Web 服务，映射到宿主机端口

CONTAINER_NAME="webserver"
CONTAINER_IP="10.100.0.10"
HOST_PORT=8080
CONTAINER_PORT=80

# 1. 创建容器（���考案例1）
# ...

# 2. 在容器内启动 Web 服务
sudo ip netns exec $CONTAINER_NAME python3 << 'PYEOF' &
from http.server import HTTPServer, BaseHTTPRequestHandler
class Handler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b'Hello from container!')
HTTPServer(('0.0.0.0', 80), Handler).serve_forever()
PYEOF

# 3. 配置端口映射（DNAT）
sudo iptables -t nat -A PREROUTING -p tcp --dport $HOST_PORT -j DNAT --to-destination $CONTAINER_IP:$CONTAINER_PORT
sudo iptables -t nat -A OUTPUT -p tcp --dport $HOST_PORT -j DNAT --to-destination $CONTAINER_IP:$CONTAINER_PORT
sudo iptables -A FORWARD -p tcp -d $CONTAINER_IP --dport $CONTAINER_PORT -j ACCEPT

# 4. 测试
curl http://localhost:8080
# Hello from container!
```

### 案例 3: 网络性能测试

```bash
# 使用 iperf3 测试容器网络性能

# 1. 在容器1中启动 iperf3 服务端
sudo ip netns exec container1 iperf3 -s &

# 2. 在容器2中测试
sudo ip netns exec container2 iperf3 -c 10.100.0.10 -t 10

# 输出示例:
# [ ID] Interval           Transfer     Bitrate
# [  5]   0.00-10.00  sec  10.0 GBytes  8.59 Gbits/sec

# 对比不同网络模式的性能:
# - veth + bridge: ~10 Gbps
# - host 模式: ~20+ Gbps (接近原生)
```

---

## 常见问题

### Q1: 容器无法访问外网？

```bash
# 检��� IP 转发
sysctl net.ipv4.ip_forward
# 如果是 0，启用它:
sudo sysctl -w net.ipv4.ip_forward=1

# 检查 NAT 规则
sudo iptables -t nat -L -n | grep MASQUERADE

# 检查路由
ip netns exec container1 ip route
# 确保有默认路由
```

### Q2: 容器间无法通信？

```bash
# 检查 IP 地址是否在同一网段
ip netns exec container1 ip addr
ip netns exec container2 ip addr

# 检查网桥连接
bridge link show

# 检查 FORWARD 规则
sudo iptables -L FORWARD -n -v
```

### Q3: 端口映射不生效？

```bash
# 检查 DNAT 规则
sudo iptables -t nat -L -n -v | grep <PORT>

# 检查容器内服务是否启动
sudo ip netns exec container1 netstat -tlnp

# 检查 FORWARD 规则
sudo iptables -L FORWARD -n -v | grep <CONTAINER_IP>
```

---

## 总结

### 核心知识点

1. **veth pair** - 连接命名空间的管道
2. **Bridge** - 虚拟交换机，连接多个容器
3. **iptables NAT** - 让容器访问外网
4. **路由** - 跨主机容器通信

### 网络通信流程

```
容器发包 → veth → bridge → iptables(NAT) → 路由 → 物理网卡 → 外网
```

### 下一步

学习 [06-手动构建容器](./06-手动构建容器.md) - 综合运用所有技术！

---

## 参考资源

- [Linux Network Namespaces](https://man7.org/linux/man-pages/man7/network_namespaces.7.html)
- [Docker Networking](https://docs.docker.com/network/)
- [Kubernetes Network Model](https://kubernetes.io/docs/concepts/cluster-administration/networking/)
- [iptables Tutorial](https://www.netfilter.org/documentation/HOWTO/packet-filtering-HOWTO.html)

---

*更新日期: 2025-12-02*
*作者: Claude Code*
