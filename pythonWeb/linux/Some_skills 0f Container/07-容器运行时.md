# 07 - 容器运行时

> 深入理解容器运行时:OCI 标准、runc、containerd 和 CRI

## 目录

- [容器运行时概述](#容器运行时概述)
- [OCI 标准](#oci-标准)
- [runc 详解](#runc-详解)
- [containerd 详解](#containerd-详解)
- [CRI 容器运行时接口](#cri-容器运行时接口)
- [运行时对比](#运行时对比)
- [实战案例](#实战案例)

---

## 容器运行时概述

【本文档是容器技术学习系列的第 07 篇】

### 什么是容器运行时

> **容器运行时 = 负责创建和管理容器生命周期的软件组件**

```
┌─────────────────────────────────────────┐
│         容器编排层 (Kubernetes)          │
└────────────────┬────────────────────────┘
                 │ CRI (容器运行时接口)
┌────────────────▼────────────────────────┐
│      高级运行时 (containerd, CRI-O)      │
│  - 镜像管理                              │
│  - 容器生命周期管理                      │
│  - 网络、存储配置                        │
└────────────────┬────────────────────────┘
                 │ OCI Runtime Spec
┌────────────────▼────────────────────────┐
│      低级运行时 (runc, crun, kata)       │
│  - 创建 namespace                        │
│  - 配置 cgroups                          │
│  - 执行容器进程                          │
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│         Linux 内核 (Namespace, Cgroups) │
└─────────────────────────────────────────┘
```

### 容器运行时分类

**1. 低级运行时 (Low-level Runtime)**
- 直接与操作系统内核交互
- 创建和运行容器
- 例如:runc、crun、kata-runtime

**2. 高级运行时 (High-level Runtime)**
- 镜像管理和传输
- 解压镜像到磁盘
- 调用低级运行时
- 例如:containerd、CRI-O、Podman

### Docker 架构演进

```
早期 Docker (< 1.11):
┌──────────┐
│  docker  │  ← 单体架构,包含所有功能
└──────────┘

现代 Docker (> 1.11):
┌──────────┐
│  docker  │  ← CLI 客户端
└────┬─────┘
     │
┌────▼──────┐
│ dockerd   │  ← Docker 守护进程
└────┬──────┘
     │
┌────▼──────────┐
│ containerd    │  ← 容器生命周期管理
└────┬──────────┘
     │
┌────▼──────┐
│   runc    │  ← OCI 运行时
└───────────┘
```

---

## OCI 标准

### 什么是 OCI

> **OCI = Open Container Initiative (开放容器标准)**
>
> 由 Docker 和 Linux 基金会于 2015 年创建,旨在标准化容器格式和运行时

### OCI 三大规范

```
┌─────────────────────────────────────────┐
│          OCI 标准                        │
├─────────────────────────────────────────┤
│  1. Runtime Spec (运行时规范)            │
│     - 如何运行容器                       │
│     - config.json 格式                   │
│     - 容器生命周期                       │
│                                          │
│  2. Image Spec (镜像规范)                │
│     - 镜像格式标准                       │
│     - 镜像清单 (manifest)                │
│     - 文件系统层                         │
│                                          │
│  3. Distribution Spec (分发规范)         │
│     - 镜像推送/拉取                      │
│     - 镜像仓库 API                       │
└─────────────────────────────────────────┘
```

### OCI Runtime Spec 核心概念

```json
{
  "ociVersion": "1.0.2",
  "process": {
    "terminal": true,
    "user": { "uid": 0, "gid": 0 },
    "args": ["/bin/sh"],
    "env": ["PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"],
    "cwd": "/",
    "capabilities": {...},
    "rlimits": [...]
  },
  "root": {
    "path": "rootfs",
    "readonly": true
  },
  "hostname": "my-container",
  "mounts": [...],
  "linux": {
    "namespaces": [
      {"type": "pid"},
      {"type": "network"},
      {"type": "ipc"},
      {"type": "uts"},
      {"type": "mount"}
    ],
    "resources": {
      "memory": {"limit": 536870912},
      "cpu": {"quota": 50000, "period": 100000}
    }
  }
}
```

---

## runc 详解

### 什么是 runc

> **runc = OCI Runtime 的参考实现,由 Docker 捐献**
>
> - Go 语言编写
> - 直接使用 Linux 内核特性
> - 是 Docker 默认的低级运行时

### 安装 runc

```bash
# 方法 1: 使用包管理器
sudo apt install runc         # Ubuntu/Debian
sudo yum install runc         # CentOS/RHEL

# 方法 2: 从源码编译
git clone https://github.com/opencontainers/runc
cd runc
make
sudo make install

# 方法 3: 下载预编译二进制
wget https://github.com/opencontainers/runc/releases/download/v1.1.10/runc.amd64
chmod +x runc.amd64
sudo mv runc.amd64 /usr/local/bin/runc

# 验证安装
runc --version
# runc version 1.1.10
```

### 使用 runc 运行容器

#### 步骤 1: 准备 rootfs

```bash
# 创建工作目录
mkdir -p /tmp/runc-container
cd /tmp/runc-container

# 从 Docker 镜像导出 rootfs
mkdir rootfs
docker export $(docker create alpine) | tar -C rootfs -xf -

# 查看 rootfs
ls rootfs/
# bin/  dev/  etc/  home/  lib/  media/  mnt/  opt/  proc/  root/  run/  sbin/  srv/  sys/  tmp/  usr/  var/
```

#### 步骤 2: 生成 OCI 配置

```bash
# 生成默认 config.json
runc spec

# 查看生成的配置
cat config.json

# 输出:
# {
#   "ociVersion": "1.0.2",
#   "process": {
#     "terminal": true,
#     "user": {"uid": 0, "gid": 0},
#     "args": ["sh"],
#     ...
#   },
#   "root": {
#     "path": "rootfs",
#     "readonly": true
#   },
#   ...
# }
```

#### 步骤 3: 运行容器

```bash
# 运行容器
sudo runc run mycontainer

# 你现在在容器内了!
/ # hostname
mycontainer

/ # ps aux
PID   USER     TIME  COMMAND
    1 root      0:00 sh

/ # ls /
bin   dev   etc   home  lib   media mnt   opt   proc  root  run   sbin  srv   sys   tmp   usr   var

/ # exit
```

### runc 核心命令

```bash
# 1. 创建容器 (不启动)
sudo runc create mycontainer

# 2. 启动已创建的容器
sudo runc start mycontainer

# 3. 运行容器 (create + start)
sudo runc run mycontainer

# 4. 列出容器
sudo runc list
# ID            PID         STATUS      BUNDLE      CREATED
# mycontainer   12345       running     /tmp/runc-  2025-12-03T...

# 5. 查看容器状态
sudo runc state mycontainer
# {
#   "ociVersion": "1.0.2",
#   "id": "mycontainer",
#   "pid": 12345,
#   "status": "running",
#   "bundle": "/tmp/runc-container",
#   ...
# }

# 6. 在容器中执行命令
sudo runc exec mycontainer ps aux

# 7. 暂停容器
sudo runc pause mycontainer

# 8. 恢复容器
sudo runc resume mycontainer

# 9. 停止容器
sudo runc kill mycontainer SIGTERM

# 10. 删除容器
sudo runc delete mycontainer
```

### 自定义 config.json

```bash
# 修改 config.json

# 1. 修改启动命令
jq '.process.args = ["/bin/sh", "-c", "echo Hello && sleep 10"]' config.json > config.json.tmp
mv config.json.tmp config.json

# 2. 添加环境变量
jq '.process.env += ["MY_VAR=hello"]' config.json > config.json.tmp
mv config.json.tmp config.json

# 3. 限制内存 (512MB)
jq '.linux.resources.memory.limit = 536870912' config.json > config.json.tmp
mv config.json.tmp config.json

# 4. 限制 CPU (0.5核)
jq '.linux.resources.cpu.quota = 50000' config.json > config.json.tmp
mv config.json.tmp config.json

# 5. 使 rootfs 可写
jq '.root.readonly = false' config.json > config.json.tmp
mv config.json.tmp config.json

# 运行修改后的容器
sudo runc run mycontainer
```

---

## containerd 详解

### 什么是 containerd

> **containerd = 工业级容器运行时,从 Docker 中分离出来**
>
> - CNCF 毕业项目
> - Docker 和 Kubernetes 都使用它
> - 负责镜像传输、容器执行、快照管理

### containerd 架构

```
┌──────────────────────────────────────┐
│           Kubernetes                  │
└────────────┬─────────────────────────┘
             │ CRI (gRPC)
┌────────────▼─────────────────────────┐
│         containerd                    │
│  ┌──────────────────────────────┐   │
│  │  CRI Plugin                  │   │
│  └──────────────────────────────┘   │
│  ┌──────────────────────────────┐   │
│  │  Image Service               │   │
│  │  - pull, push, list          │   │
│  └──────────────────────────────┘   │
│  ┌──────────────────────────────┐   │
│  │  Container Service           │   │
│  │  - create, start, stop       │   │
│  └──────────────────────────────┘   │
│  ┌──────────────────────────────┐   │
│  │  Snapshot Service            │   │
│  │  - overlay, btrfs, zfs       │   │
│  └──────────────────────────────┘   │
│  ┌──────────────────────────────┐   │
│  │  Task Service                │   │
│  └────────────┬─────────────────┘   │
└───────────────┼─────────────────────┘
                │
┌───────────────▼─────────────────────┐
│         containerd-shim              │
│  - 管理容器生命周期                  │
│  - 保持容器运行(即使containerd重启) │
└───────────────┬─────────────────────┘
                │
┌───────────────▼─────────────────────┐
│             runc                     │
└─────────────────────────────────────┘
```

### 安装 containerd

```bash
# 方法 1: 使用 Docker
# containerd 已包含在 Docker 中
sudo apt install docker.io

# 方法 2: 独立安装
# 下载 containerd
wget https://github.com/containerd/containerd/releases/download/v1.7.10/containerd-1.7.10-linux-amd64.tar.gz
sudo tar -C /usr/local -xzf containerd-1.7.10-linux-amd64.tar.gz

# 创建 systemd 服务
sudo mkdir -p /usr/local/lib/systemd/system/
cat << EOF | sudo tee /usr/local/lib/systemd/system/containerd.service
[Unit]
Description=containerd container runtime
Documentation=https://containerd.io
After=network.target

[Service]
ExecStart=/usr/local/bin/containerd
Restart=always
RestartSec=5
Delegate=yes
KillMode=process
OOMScoreAdjust=-999
LimitNOFILE=1048576
LimitNPROC=infinity
LimitCORE=infinity

[Install]
WantedBy=multi-user.target
EOF

# 启动 containerd
sudo systemctl daemon-reload
sudo systemctl enable containerd
sudo systemctl start containerd

# 验证
sudo systemctl status containerd
```

### 使用 ctr (containerd CLI)

```bash
# ctr 是 containerd 的命令行工具

# 1. 拉取镜像
sudo ctr images pull docker.io/library/nginx:latest

# 2. 列出镜像
sudo ctr images ls
# REF                            TYPE      SIZE
# docker.io/library/nginx:latest sha256... 142.8 MiB

# 3. 运行容器
sudo ctr run --rm -t docker.io/library/nginx:latest mynginx /bin/sh

# 4. 列出容器
sudo ctr containers ls
# CONTAINER    IMAGE                             RUNTIME
# mynginx      docker.io/library/nginx:latest    io.containerd.runc.v2

# 5. 查看容器任务
sudo ctr tasks ls
# TASK       PID      STATUS
# mynginx    12345    RUNNING

# 6. 在容器中执行命令
sudo ctr tasks exec --exec-id mytask mynginx ps aux

# 7. 停止容器
sudo ctr tasks kill mynginx

# 8. 删除容器
sudo ctr containers rm mynginx

# 9. 删除镜像
sudo ctr images rm docker.io/library/nginx:latest

# 10. 查看命名空间
sudo ctr namespaces ls
# NAME    LABELS
# default
# k8s.io  (Kubernetes 使用)
```

### containerd vs Docker

| 特性              | containerd                | Docker                   |
|------------------|---------------------------|--------------------------|
| **定位**          | 容器运行时                | 完整容器平台             |
| **功能**          | 核心容器功能              | 容器 + 工具 + 生态      |
| **CLI**           | ctr (简单)                | docker (丰富)           |
| **镜像构建**      | 不支持                    | 支持 (docker build)     |
| **网络**          | 基础                      | 完善 (docker network)   |
| **卷管理**        | 基础                      | 完善 (docker volume)    |
| **性能**          | 更轻量                    | 略重                    |
| **使用场景**      | Kubernetes, 生产环境      | 开发、学习、部署        |

---

## CRI 容器运行时接口

### 什么是 CRI

> **CRI = Container Runtime Interface (容器运行时接口)**
>
> - Kubernetes 定义的容器运行时标准接口
> - 使用 gRPC 协议
> - 解耦 Kubernetes 和容器运行时

### CRI 架构

```
┌──────────────────────────────────────┐
│           kubelet                     │
│  (Kubernetes 节点代理)                │
└────────────┬─────────────────────────┘
             │ CRI API (gRPC)
             │
    ┌────────▼────────┐
    │  RuntimeService │  ← 管理容器和 Pod
    │  - RunPodSandbox│
    │  - CreateContainer
    │  - StartContainer│
    │  - StopContainer │
    └─────────────────┘
    ┌─────────────────┐
    │  ImageService   │  ← 管理镜像
    │  - PullImage    │
    │  - ListImages   │
    │  - RemoveImage  │
    └─────────────────┘
             │
┌────────────▼─────────────────────────┐
│     CRI Runtime Implementation       │
│  (containerd-cri, CRI-O, etc.)       │
└──────────────────────────────────────┘
```

### CRI 兼容的运行时

**1. containerd (with CRI plugin)**
```bash
# 默认配置已包含 CRI 插件
sudo containerd config default > /etc/containerd/config.toml

# 重启 containerd
sudo systemctl restart containerd
```

**2. CRI-O**
```bash
# 专为 Kubernetes 设计的轻量级运行时
sudo apt install cri-o cri-o-runc

# 启动 CRI-O
sudo systemctl start crio
```

**3. Docker (通过 cri-dockerd)**
```bash
# Docker 需要适配器来支持 CRI
git clone https://github.com/Mirantis/cri-dockerd
cd cri-dockerd
go build
sudo mv cri-dockerd /usr/local/bin/
```

### 使用 crictl 调试

```bash
# crictl 是 CRI 的命令行工具

# 安装 crictl
VERSION="v1.28.0"
wget https://github.com/kubernetes-sigs/cri-tools/releases/download/$VERSION/crictl-$VERSION-linux-amd64.tar.gz
sudo tar -C /usr/local/bin -xzf crictl-$VERSION-linux-amd64.tar.gz

# 配置 crictl
cat <<EOF | sudo tee /etc/crictl.yaml
runtime-endpoint: unix:///run/containerd/containerd.sock
image-endpoint: unix:///run/containerd/containerd.sock
timeout: 10
debug: false
EOF

# 使用 crictl

# 1. 列出镜像
sudo crictl images

# 2. 拉取镜像
sudo crictl pull nginx:latest

# 3. 列出 Pod
sudo crictl pods

# 4. 创建 Pod
sudo crictl runp pod-config.json

# 5. 列出容器
sudo crictl ps -a

# 6. 查看容器日志
sudo crictl logs <container-id>

# 7. 在容器中执行命令
sudo crictl exec -it <container-id> /bin/sh

# 8. 停止容器
sudo crictl stop <container-id>

# 9. 删除容器
sudo crictl rm <container-id>

# 10. 删除 Pod
sudo crictl stopp <pod-id>
sudo crictl rmp <pod-id>
```

---

## 运行时对比

### 低级运行时对比

| 运行时       | 语言  | 性能  | 特点                        | 使用场景         |
|-------------|------|------|----------------------------|-----------------|
| **runc**    | Go   | 快   | OCI 参考实现,最成熟         | 通用,默认选择   |
| **crun**    | C    | 很快 | 性能优秀,内存占用小         | 性能敏感场景    |
| **kata**    | Go   | 慢   | 基于虚拟机,安全性高         | 多租户,安全场景 |
| **gVisor**  | Go   | 中   | 用户空间内核,安全隔离       | 不受信任的负载  |

### 高级运行时对比

| 运行时         | 特点                                  | K8s 集成 | 使用场景             |
|---------------|--------------------------------------|----------|---------------------|
| **containerd**| Docker 同源,功能完善,CNCF 项目        | 原生支持 | 生产环境,推荐       |
| **CRI-O**     | 专为 K8s 设计,轻量级                  | 原生支持 | K8s 专用集群        |
| **Docker**    | 功能最丰富,生态最好                   | 需适配器 | 开发环境,混合部署   |
| **Podman**    | 无守护进程,rootless,兼容 Docker CLI   | 通过 CRI | Rootless 场景       |

### 性能对比实验

```bash
#!/bin/bash
# benchmark_runtimes.sh

# 测试不同运行时启动容器的速度

echo "=== runc 性能测试 ==="
time sudo runc run --bundle /tmp/runc-container test1

echo "=== containerd 性能测试 ==="
time sudo ctr run --rm docker.io/library/alpine:latest test2 /bin/true

echo "=== Docker 性能测试 ==="
time docker run --rm alpine:latest /bin/true

# 典型结果:
# runc:       0.05s  ← 最快
# containerd: 0.15s
# Docker:     0.30s  ← 需经过多层
```

---

## 实战案例

### 案例 1: 使用 runc 运行 Web 服务

```bash
#!/bin/bash
# runc_web_server.sh

# 1. 准备目录
mkdir -p /tmp/runc-web/{rootfs,bundle}
cd /tmp/runc-web

# 2. 导出 rootfs
docker export $(docker create nginx) | tar -C rootfs -xf -

# 3. 生成 config.json
runc spec

# 4. 修改配置
jq '.process.args = ["nginx", "-g", "daemon off;"]' config.json > config.json.tmp
mv config.json.tmp config.json

# 5. 设置 rootfs 可写
jq '.root.readonly = false' config.json > config.json.tmp
mv config.json.tmp config.json

# 6. 运行容器
sudo runc run nginx-container

# 容器运行中,在另一个终端:
# sudo runc exec nginx-container curl localhost
```

### 案例 2: containerd + K8s Pod

```yaml
# pod.yaml - 使用 containerd 运行 Pod
apiVersion: v1
kind: Pod
metadata:
  name: test-pod
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
  runtimeClassName: runc  # 指定运行时
```

```bash
# 应用 Pod
kubectl apply -f pod.yaml

# 查看 containerd 中的容器
sudo crictl ps
# CONTAINER ID   IMAGE          NAME     STATE
# abc123...      nginx:latest   nginx    Running

# 查看容器详情
sudo crictl inspect abc123

# 查看日志
sudo crictl logs abc123
```

### 案例 3: 对比不同运行时

```bash
#!/bin/bash
# compare_runtimes.sh

# 1. runc - 最底层
echo "=== 使用 runc ==="
cd /tmp/runc-test
runc spec
sudo runc run test-runc

# 2. containerd - 高级运行时
echo "=== 使用 containerd ==="
sudo ctr run --rm -t docker.io/library/alpine:latest test-containerd /bin/sh

# 3. Docker - 完整平台
echo "=== 使用 Docker ==="
docker run --rm -it alpine:latest /bin/sh

# 观察启动速度、内存占用、功能差异
```

---

## 常见问题

### Q1: containerd 和 Docker 的关系?

```
历史:
  Docker (单体) → Docker 拆分 → Docker Engine = dockerd + containerd + runc

现在:
  Docker 使用 containerd 作为底层运行时
  containerd 也可以独立使用

选择:
  - 开发: Docker (工具丰富)
  - 生产/K8s: containerd (轻量、稳定)
```

### Q2: Kubernetes 应该选择哪个运行时?

推荐顺序:
1. **containerd** - 最佳选择,成熟稳定
2. **CRI-O** - 专为 K8s 设计,轻量级
3. **Docker** - 需要额外适配,不推荐新集群

```bash
# 查看 K8s 使用的运行时
kubectl get nodes -o wide
# NAME    STATUS   VERSION   CONTAINER-RUNTIME
# node1   Ready    v1.28.0   containerd://1.7.10
```

### Q3: 如何切换容器运行时?

```bash
# 1. 停止旧运行时
sudo systemctl stop docker

# 2. 安装新运行时
sudo apt install containerd

# 3. 配置 Kubernetes
sudo vim /etc/systemd/system/kubelet.service.d/10-kubeadm.conf
# 修改:--container-runtime=remote
#      --container-runtime-endpoint=unix:///run/containerd/containerd.sock

# 4. 重启 kubelet
sudo systemctl daemon-reload
sudo systemctl restart kubelet
```

---

## 总结

### 核心概念

```
OCI 标准
  ├─ Runtime Spec (如何运行容器)
  ├─ Image Spec (镜像格式)
  └─ Distribution Spec (镜像分发)

运行时层次
  ├─ 低级运行时:runc, crun, kata
  └─ 高级运行时:containerd, CRI-O, Docker

接口标准
  └─ CRI (Kubernetes 容器运行时接口)
```

### 关键技术栈

```
应用层:   Docker CLI, kubectl, crictl
       ↓
高级运行时: containerd, CRI-O
       ↓
CRI 接口:  RuntimeService, ImageService
       ↓
低级运行时: runc, crun
       ↓
内核:     Namespace, Cgroups, OverlayFS
```

### 最佳实践

1. **生产环境** - 使用 containerd,稳定高效
2. **开发环境** - 使用 Docker,工具丰富
3. **Kubernetes** - 使用 containerd 或 CRI-O
4. **高安全场景** - 使用 kata-containers (VM 隔离)
5. **性能优先** - 使用 crun (C 实现,快速)

### 下一步

学习 [08-Docker深入理解](./08-Docker深入理解.md) - 掌握工业级容器平台!

---

## 参考资源

- [OCI Runtime Spec](https://github.com/opencontainers/runtime-spec)
- [containerd 官方文档](https://containerd.io/)
- [runc 项目](https://github.com/opencontainers/runc)
- [CRI-O 官方文档](https://cri-o.io/)
- [Kubernetes CRI](https://kubernetes.io/docs/concepts/architecture/cri/)

---

*更新日期: 2025-12-03*
*作者: Claude Code*
