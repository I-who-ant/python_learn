# 对象管���

> 命令式 vs 声明式、kubectl 管理对象、最佳实践

## 对象管理方式对比

Kubernetes 提供三种对象管理方式：

### 1. 命令式命令（Imperative Commands）

直接通过命令行操作，不需���配置文件。

```bash
# 创建
kubectl run nginx --image=nginx
kubectl create deployment nginx --image=nginx

# 暴露
kubectl expose deployment nginx --port=80 --type=LoadBalancer

# 扩缩容
kubectl scale deployment nginx --replicas=3

# 删除
kubectl delete deployment nginx
```

**优点**：
- ✅ 快速简单
- ✅ 学习门槛低
- ✅ 适合实验和调试

**缺点**：
- ❌ 无法追溯历史
- ❌ 难以版本控制
- ❌ 不适合复杂配置
- ❌ 团队协作困难

**适用场景**：
- 快速测试
- 一次性任务
- 开发调试

### 2. 命令式对象配置（Imperative Object Configuration）

使用配置文件，通过 create/replace/delete 命令管理。

```bash
# 创建配置文件
cat > nginx.yaml << 'EOF'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.19
EOF

# 创建对象
kubectl create -f nginx.yaml

# 更新对象（必须先删除）
kubectl replace -f nginx.yaml

# 或者强制替换
kubectl replace --force -f nginx.yaml

# 删除对象
kubectl delete -f nginx.yaml
```

**优点**：
- ✅ 配置可追溯
- ✅ 支持版本控制
- ✅ 可以团队协作

**缺点**：
- ❌ 更新需要完整配置
- ❌ 不支持部分更新
- ❌ 需要手动管理状态

**适用场景**：
- 简单的配置管理
- 已有完整配置文件
- 一次性部署

### 3. 声明式对象配置（Declarative Object Configuration）⭐

使用配置文件，通过 apply 命令声明期望状态。

```bash
# 创建/更新对象
kubectl apply -f nginx.yaml

# 应用整个目录
kubectl apply -f ./configs/

# 递归应用
kubectl apply -R -f ./manifests/

# 查看将要应用的更改（dry-run）
kubectl apply -f nginx.yaml --dry-run=client -o yaml

# 服务端 dry-run
kubectl apply -f nginx.yaml --dry-run=server
```

**优点**：
- ✅ GitOps 友好
- ✅ 支持部分更新
- ✅ 自动合���更改
- ✅ 支持多文件操作
- ✅ 生产环境推荐

**缺点**：
- ❌ 学习曲线稍陡
- ❌ 需要理解合并逻辑

**适用场景**：
- ✅ 生产环境（强烈推荐）
- ✅ GitOps 工作流
- ✅ CI/CD 流程
- ✅ 团队协作

## 声明式管理深入

### apply 的工作原理

```
1. kubectl apply -f nginx.yaml
       ↓
2. kubectl 读取本地配置
       ↓
3. 通过 API Server 获取当前对象状态
       ↓
4. 计算三方合并 (3-way merge)
   - 本地配置
   - 当前状态
   - 上次应用的配置
       ↓
5. 生成补丁 (patch)
       ↓
6. 应用补丁到集群
```

### 三方合并示例

```yaml
# 第一次 apply
spec:
  replicas: 3
  containers:
  - name: nginx
    image: nginx:1.19

# 手动修改（通过 kubectl edit）
spec:
  replicas: 5  # 手动改为 5
  containers:
  - name: nginx
    image: nginx:1.19

# 第二次 apply
spec:
  replicas: 3  # 配置文件仍是 3
  containers:
  - name: nginx
    image: nginx:1.20  # 只改了镜像

# 结果（智能合并）
spec:
  replicas: 5  # 保留手动修改
  containers:
  - name: nginx
    image: nginx:1.20  # 应用配置更改
```

### Last-Applied-Configuration

```bash
# 查看上次应用的配置
kubectl get deployment nginx -o yaml | grep -A 100 last-applied-configuration

# 每个对象的 annotation 中存储
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"apps/v1","kind":"Deployment",...}
```

## kubectl 命令详解

### 基本操作

#### 创建对象

```bash
# apply（推荐）
kubectl apply -f nginx.yaml

# create（首次创建）
kubectl create -f nginx.yaml

# 从标准输入创建
cat nginx.yaml | kubectl create -f -

# 从 URL 创建
kubectl create -f https://example.com/nginx.yaml

# 创建并记录变更
kubectl create -f nginx.yaml --record
```


#### 查看对象

```bash
# 列出所有 Pod
kubectl get pods

# 所有命名空间
kubectl get pods --all-namespaces
kubectl get pods -A

# 显示更多信息
kubectl get pods -o wide

# 查看详细信息
kubectl describe pod nginx

# YAML 格式
kubectl get pod nginx -o yaml

# JSON 格式
kubectl get pod nginx -o json

# 自定义列
kubectl get pods -o custom-columns=NAME:.metadata.name,STATUS:.status.phase

# JSONPath
kubectl get pods -o jsonpath='{.items[*].metadata.name}'

# 监听变化
kubectl get pods --watch
kubectl get pods -w
```

#### 更新对象

```bash
# apply（推荐）
kubectl apply -f nginx.yaml

# edit（在线编辑）
kubectl edit deployment nginx

# patch（补丁更新）
kubectl patch deployment nginx -p '{"spec":{"replicas":5}}'

# set image
kubectl set image deployment/nginx nginx=nginx:1.20

# set resources
kubectl set resources deployment nginx -c=nginx --limits=cpu=200m,memory=512Mi

# replace（替换）
kubectl replace -f nginx.yaml

# replace --force（强制替换，会删除重建）
kubectl replace --force -f nginx.yaml
```

#### 删除对象

```bash
# 删除指定对象
kubectl delete pod nginx

# 通过文件删除
kubectl delete -f nginx.yaml

# 删除所有 Pod
kubectl delete pods --all

# 删除指定标签的对象
kubectl delete pods -l app=nginx

# 级联删除（默认）
kubectl delete deployment nginx

# 非级联删除（孤立 Pod）
kubectl delete deployment nginx --cascade=orphan

# 强制删除
kubectl delete pod nginx --force --grace-period=0
```

### 高级操作

#### 日志查看

```bash
# 查看 Pod 日志
kubectl logs nginx

# 实时查看
kubectl logs -f nginx

# 查看前 100 行
kubectl logs --tail=100 nginx

# 查看最近 1 小时的日志
kubectl logs --since=1h nginx

# 多容器 Pod（指定容器）
kubectl logs nginx -c container-name

# 查看上一个容器的日志
kubectl logs nginx --previous

# 所有 Pod 的日志
kubectl logs -l app=nginx --all-containers=true
```

#### 执行命令

```bash
# 在 Pod 中执行命令
kubectl exec nginx -- ls /

# 交互式 shell
kubectl exec -it nginx -- /bin/bash

# 多容器 Pod
kubectl exec -it nginx -c container-name -- /bin/bash

# 执行多个命令
kubectl exec nginx -- sh -c "ls / && pwd"
```

#### 端口转发

```bash
# 转发本地端口到 Pod
kubectl port-forward pod/nginx 8080:80

# 转发到 Service
kubectl port-forward service/nginx 8080:80

# 转发到 Deployment
kubectl port-forward deployment/nginx 8080:80

# 监听所有地址
kubectl port-forward --address 0.0.0.0 pod/nginx 8080:80
```

#### 文件复制

```bash
# 从 Pod 复制文件到本地
kubectl cp nginx:/var/log/nginx/access.log ./access.log

# 从本地复制文件到 Pod
kubectl cp ./local-file.txt nginx:/tmp/file.txt

# 多容器 Pod
kubectl cp nginx:/file.txt ./file.txt -c container-name
```

#### 资源使用

```bash
# 查看节点资源使用
kubectl top nodes

# 查看 Pod 资源使用
kubectl top pods

# 指定命名空间
kubectl top pods -n kube-system

# 排序
kubectl top pods --sort-by=cpu
kubectl top pods --sort-by=memory

# 查看容器级别
kubectl top pods --containers
```

### 上下文和配置

```bash
# 查看配置
kubectl config view

# 查看当前上下文
kubectl config current-context

# 列出所有上下文
kubectl config get-contexts

# 切换上下文
kubectl config use-context my-cluster

# 设置默认命名空间
kubectl config set-context --current --namespace=my-namespace

# 创建新上下文
kubectl config set-context my-context --cluster=my-cluster --user=my-user --namespace=default
```

## 配置文件最佳实践

### 1. 文件组织

```
项目目录/
├── base/                    # 基础配置
│   ├── deployment.yaml
│   ├── service.yaml
│   └── configmap.yaml
├── overlays/               # 环境覆盖
│   ├── dev/
│   │   ├── kustomization.yaml
│   │   └── patch.yaml
│   ├── staging/
│   │   ├── kustomization.yaml
│   │   └── patch.yaml
│   └── prod/
│       ├── kustomization.yaml
│       └── patch.yaml
└── README.md
```

### 2. YAML 编写规范

```yaml
# ✅ 好的做法
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
    version: v1.0.0
    environment: production
  annotations:
    description: "Nginx web server"
    contact: "ops@example.com"
spec:
  replicas: 3
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
        version: v1.0.0
    spec:
      containers:
      - name: nginx
        image: nginx:1.19-alpine
        ports:
        - name: http
          containerPort: 80
          protocol: TCP
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 200m
            memory: 256Mi
        livenessProbe:
          httpGet:
            path: /healthz
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5

---
# ❌ 避免的做法
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx  # 名称太简单
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    spec:
      containers:
      - name: nginx
        image: nginx:latest  # 不要用 latest
        # 缺少资源限制
        # 缺少健康检查
```

### 3. 多文档文件

```yaml
# app.yaml - 包含多个对象
apiVersion: v1
kind: Namespace
metadata:
  name: myapp

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: myapp
data:
  app.conf: |
    server {
      listen 80;
    }

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app
  namespace: myapp
spec:
  replicas: 3
  # ...

---
apiVersion: v1
kind: Service
metadata:
  name: app
  namespace: myapp
spec:
  # ...
```

### 4. 使用 Kustomize

```bash
# base/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
- deployment.yaml
- service.yaml
- configmap.yaml

commonLabels:
  app: myapp

# overlays/prod/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

bases:
- ../../base

replicas:
- name: myapp
  count: 5

images:
- name: myapp
  newTag: v1.0.0

# 应用
kubectl apply -k overlays/prod/
```

## GitOps 工作流

### 1. Git 作为唯一真相来源

```
开发者              Git 仓库           K8s 集群
  │                   │                  │
  │ 1. 修改 YAML      │                  │
  │ ─────────────────>│                  │
  │                   │                  │
  │ 2. 提交 PR        │                  │
  │ ─────────────────>│                  │
  │                   │                  │
  │ 3. Review & Merge │                  │
  │ ─────────────────>│                  │
  │                   │                  │
  │                   │ 4. 自动同步       │
  │                   │ ─────────────────>│
  │                   │                  │
  │                   │ 5. 应用更改       │
  │                   │                  │ ✓
```

### 2. 使用 Argo CD

```yaml
# argocd-app.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: myapp
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/myorg/myapp
    targetRevision: HEAD
    path: k8s
  destination:
    server: https://kubernetes.default.svc
    namespace: myapp
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
```

### 3. CI/CD 集成

```yaml
# .github/workflows/deploy.yaml
name: Deploy to K8s

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v1
    
    - name: Deploy to K8s
      run: |
        kubectl apply -f k8s/
      env:
        KUBECONFIG: ${{ secrets.KUBECONFIG }}
```

## 常见问题

### Q1: apply vs create 的区别？

```bash
# create - 只能创建，对象存在会报错
kubectl create -f nginx.yaml
# Error: already exists

# apply - 创建或更新
kubectl apply -f nginx.yaml
# deployment.apps/nginx configured
```

### Q2: replace vs apply 的区别？

```bash
# replace - 完全替换（需要完整配置）
kubectl replace -f nginx.yaml
# 会删除未在配置中的字段

# apply - 智能合并（只更新变化的部分）
kubectl apply -f nginx.yaml
# 保留未在配置中但已存在的字段
```

### Q3: 如何回滚配置？

```bash
# 使用 Git
git revert HEAD
kubectl apply -f nginx.yaml

# 使用 Deployment 回滚
kubectl rollout undo deployment/nginx

# 回滚到特定版本
kubectl rollout undo deployment/nginx --to-revision=2
```

## 最佳实践总结

### DO ✅

1. **使用声明式配置**
   ```bash
   kubectl apply -f app.yaml
   ```

2. **配置存储在 Git**
   ```bash
   git add k8s/
   git commit -m "Update deployment"
   ```

3. **使用命名空间隔离**
   ```yaml
   metadata:
     namespace: production
   ```

4. **添加标签和注解**
   ```yaml
   labels:
     app: myapp
     version: v1.0.0
   annotations:
     description: "My application"
   ```

5. **设置资源限制**
   ```yaml
   resources:
     requests:
       cpu: 100m
       memory: 128Mi
     limits:
       cpu: 200m
       memory: 256Mi
   ```

### DON'T ❌

1. **不要使用 latest 标签**
   ```yaml
   # ❌
   image: nginx:latest
   
   # ✅
   image: nginx:1.19.0
   ```

2. **不要忽略健康检查**
   ```yaml
   # ❌ 缺少探针
   
   # ✅ 添加探针
   livenessProbe:
     httpGet:
       path: /health
       port: 8080
   ```

3. **不要直接在生产环境测试**
   ```bash
   # ❌
   kubectl apply -f untested.yaml -n production
   
   # ✅
   kubectl apply -f app.yaml --dry-run=server
   ```

---

**下一步**: 学习 [标签和选择算符](./03-标签和选择算符.md)

*更新日期: 2025-12-03*
