# 控制器模式

> 控制器工作原理、控制循环、Reconcile

## 概述

【本文档是 Kubernetes 知识体系的一部分】

**控制器模式(Controller Pattern)是 Kubernetes 的核心设计模式**,体现了声明式 API 的精髓。控制器通过持续的控制循环,不断将集群的实际状态调谐到期望状态,实现了自动化运维和自愈能力。

## 核心概念

### 什么是控制器

控制器是一个控制循环,它通过 API Server 监控集群的共享状态,并尝试将当前状态迁移到期望状态。

```
┌──────────────────────────────────────┐
│         控制器工作原理                 │
│                                      │
│  ┌────────────┐                     │
│  │  期望状态   │ (用户声明)          │
│  │ Desired    │                     │
│  └─────┬──────┘                     │
│        │                             │
│        ▼                             │
│  ┌────────────┐     不相等?          │
│  │  对比差异   │ ───────────►       │
│  └─────┬──────┘                     │
│        │                             │
│        ▼                             │
│  ┌────────────┐                     │
│  │  执行调谐   │ (创建/更新/删除)    │
│  │ Reconcile  │                     │
│  └─────┬──────┘                     │
│        │                             │
│        ▼                             │
│  ┌────────────┐                     │
│  │  当前状态   │ (集群实际)          │
│  │ Current    │                     │
│  └────────────┘                     │
│        │                             │
│        └─────► 循环继续               │
└──────────────────────────────────────┘
```

### 控制器的三大要素

1. **Watch**: 监听资源变化
2. **Compare**: 对比期望与实际状态
3. **Reconcile**: 执行调谐操作

## 控制循环原理

### 基础控制循环

```go
// 简化的控制器伪代码
func (c *Controller) Run(stopCh <-chan struct{}) {
    // 1. 启动 informer,监听资源变化
    go c.informer.Run(stopCh)

    // 2. 等待缓存同步
    if !cache.WaitForCacheSync(stopCh, c.informer.HasSynced) {
        return
    }

    // 3. 启动 worker goroutines
    for i := 0; i < workers; i++ {
        go wait.Until(c.runWorker, time.Second, stopCh)
    }

    <-stopCh
}

func (c *Controller) runWorker() {
    for c.processNextItem() {
    }
}

func (c *Controller) processNextItem() bool {
    // 1. 从队列获取对象
    key, quit := c.queue.Get()
    if quit {
        return false
    }
    defer c.queue.Done(key)

    // 2. 执行调谐逻辑
    err := c.syncHandler(key.(string))

    // 3. 处理错误(重试)
    if err != nil {
        c.queue.AddRateLimited(key)
        return true
    }

    c.queue.Forget(key)
    return true
}

func (c *Controller) syncHandler(key string) error {
    // 1. 获取对象
    namespace, name, _ := cache.SplitMetaNamespaceKey(key)
    obj, err := c.lister.Get(namespace, name)
    if err != nil {
        return err
    }

    // 2. 读取期望状态
    desired := obj.Spec

    // 3. 获取当前状态
    current := c.getCurrentState(obj)

    // 4. 对比差异并调谐
    if current != desired {
        return c.reconcile(obj, desired, current)
    }

    return nil
}
```

### Watch 机制详解

```go
// Informer 工作原理
type Informer struct {
    // Reflector: 从 API Server 获取资源并存入 DeltaFIFO
    reflector *Reflector

    // Indexer: 本地缓存,提供快速查询
    indexer cache.Indexer

    // Controller: 从 DeltaFIFO 取出对象,调用 handler
    controller cache.Controller
}

// 事件处理器
type ResourceEventHandler interface {
    OnAdd(obj interface{})
    OnUpdate(oldObj, newObj interface{})
    OnDelete(obj interface{})
}

// 使用示例
informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
    AddFunc: func(obj interface{}) {
        key, _ := cache.MetaNamespaceKeyFunc(obj)
        queue.Add(key)
    },
    UpdateFunc: func(oldObj, newObj interface{}) {
        key, _ := cache.MetaNamespaceKeyFunc(newObj)
        queue.Add(key)
    },
    DeleteFunc: func(obj interface{}) {
        key, _ := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)
        queue.Add(key)
    },
})
```

## 内置控制器详解

### 1. Deployment Controller

#### 职责

- 管理 ReplicaSet 的创建、更新、删除
- 实现滚动更新和回滚
- 维护 Deployment 的历史版本

#### 工作流程

```
用户创建 Deployment
       ↓
Deployment Controller Watch 到事件
       ↓
创建 ReplicaSet (revision=1)
       ↓
ReplicaSet Controller 创建 Pod
       ↓
用户更新 Deployment.spec.template
       ↓
Deployment Controller 检测变化
       ↓
创建新 ReplicaSet (revision=2)
       ↓
按照 strategy 执行滚动更新:
  - 新 ReplicaSet 逐步扩容
  - 旧 ReplicaSet 逐步缩容
       ↓
更新完成,保留旧 ReplicaSet(replicas=0)
```

#### 配置示例

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1        # 最多超出期望副本数
      maxUnavailable: 1  # 最多不可用副本数
  revisionHistoryLimit: 10  # 保留历史版本数
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.21
```

#### 常用操作

```bash
# 查看 Deployment 状态
kubectl get deployment nginx

# 查看 ReplicaSet
kubectl get rs

# 查看滚动更新状态
kubectl rollout status deployment/nginx

# 更新镜像(触发滚动更新)
kubectl set image deployment/nginx nginx=nginx:1.22

# 查看历史版本
kubectl rollout history deployment/nginx

# 回滚到上一版本
kubectl rollout undo deployment/nginx

# 回滚到指定版本
kubectl rollout undo deployment/nginx --to-revision=2

# 暂停滚动更新
kubectl rollout pause deployment/nginx

# 恢复滚动更新
kubectl rollout resume deployment/nginx
```

---

### 2. ReplicaSet Controller

#### 职责

- 维护指定数量的 Pod 副本
- Pod 失败时自动重建
- 支持标签选择器匹配 Pod

#### 工作流程

```
ReplicaSet 创建/更新
       ↓
Controller 获取匹配的 Pod
       ↓
计算差异: desired - current
       ↓
差异 > 0 ? 创建 Pod
差异 < 0 ? 删除 Pod
差异 = 0 ? 无操作
       ↓
等待下次同步
```

#### 配置示例

```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: nginx-rs
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.21
```

---

### 3. StatefulSet Controller

#### 职责

- 管理有状态应用
- 提供稳定的网络标识(Pod 名称固定)
- 提供稳定的存储(PVC 与 Pod 绑定)
- 有序部署、扩缩容、更新

#### 工作流程

```
有序创建 Pod:
  nginx-0 → Ready
  nginx-1 → Ready
  nginx-2 → Ready

更新策略:
  RollingUpdate: 从 nginx-2 → nginx-1 → nginx-0 逆序更新
  OnDelete: 手动删除后才更新

缩容:
  从 nginx-2 开始删除(保留 PVC)

扩容:
  创建 nginx-3(复用或创建新 PVC)
```

#### 配置示例

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: nginx
spec:
  serviceName: "nginx"
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.21
        ports:
        - containerPort: 80
        volumeMounts:
        - name: data
          mountPath: /usr/share/nginx/html
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 1Gi
```

---

### 4. DaemonSet Controller

#### 职责

- 确保每个节点运行一个 Pod 副本
- 新节点加入时自动部署 Pod
- 节点删除时自动清理 Pod

#### 使用场景

- 日志收集: fluentd, logstash
- 监控代理: node-exporter, datadog-agent
- 网络插件: calico-node, kube-proxy
- 存储插件: ceph-osd, glusterd

#### 配置示例

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluentd
  namespace: kube-system
spec:
  selector:
    matchLabels:
      name: fluentd
  template:
    metadata:
      labels:
        name: fluentd
    spec:
      tolerations:
      - key: node-role.kubernetes.io/master
        effect: NoSchedule
      containers:
      - name: fluentd
        image: fluentd:v1.14
        resources:
          limits:
            memory: 200Mi
          requests:
            cpu: 100m
            memory: 200Mi
        volumeMounts:
        - name: varlog
          mountPath: /var/log
      volumes:
      - name: varlog
        hostPath:
          path: /var/log
```

---

### 5. Job Controller

#### 职责

- 管理一次性任务
- 确保 Pod 成功完成指定次数
- 支持并行执行

#### 配置示例

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: pi
spec:
  completions: 5        # 需要成功完成 5 次
  parallelism: 2        # 并行执行 2 个 Pod
  backoffLimit: 4       # 失败重试次数
  activeDeadlineSeconds: 100  # 超时时间
  template:
    spec:
      containers:
      - name: pi
        image: perl:5.34
        command: ["perl", "-Mbignum=bpi", "-wle", "print bpi(2000)"]
      restartPolicy: Never
```

#### CronJob 定时任务

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: hello
spec:
  schedule: "*/1 * * * *"  # 每分钟执行
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: hello
            image: busybox:1.35
            command:
            - /bin/sh
            - -c
            - date; echo Hello from the Kubernetes cluster
          restartPolicy: OnFailure
```

---

### 6. Node Controller

#### 职责

- 监控节点健康状态
- 设置节点 Conditions(Ready, MemoryPressure, DiskPressure)
- 驱逐不健康节点上的 Pod
- 管理节点生命周期

#### 工作逻辑

```bash
# 节点状态检查周期
--node-monitor-period=5s

# 节点心跳超时阈值
--node-monitor-grace-period=40s

# Pod 驱逐超时
--pod-eviction-timeout=5m

# 节点状态机:
Ready → Unknown (40s 无心跳) → NotReady → 驱逐 Pod
```

---

### 7. Endpoints Controller

#### 职责

- 维护 Service 与 Pod 的映射关系
- 监听 Service 和 Pod 变化
- 更新 Endpoints 对象

#### 工作流程

```
Service 创建
       ↓
Endpoints Controller Watch 事件
       ↓
查找匹配 selector 的 Pod
       ↓
提取 Pod IP 和 Port
       ↓
创建 Endpoints 对象
       ↓
Pod 变化时更新 Endpoints
```

#### 查看 Endpoints

```bash
# 查看 Endpoints
kubectl get endpoints

# 详细信息
kubectl describe endpoints nginx

# 示例输出
Name:         nginx
Namespace:    default
Labels:       app=nginx
Subsets:
  Addresses:    10.244.1.5,10.244.2.6,10.244.3.7
  Ports:
    Name  Port  Protocol
    ----  ----  --------
    http  80    TCP
```

---

## 自定义控制器

### Operator 模式

**Operator = CRD + Custom Controller**

Operator 是一种打包、部署和管理 Kubernetes 应用的方法,它将人类运维知识编码为软件。

#### 示例: MySQL Operator

##### 1. 定义 CRD

```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: mysqls.database.example.com
spec:
  group: database.example.com
  versions:
  - name: v1
    served: true
    storage: true
    schema:
      openAPIV3Schema:
        type: object
        properties:
          spec:
            type: object
            properties:
              version:
                type: string
              replicas:
                type: integer
              storage:
                type: string
  scope: Namespaced
  names:
    plural: mysqls
    singular: mysql
    kind: MySQL
```

##### 2. 创建 MySQL 实例

```yaml
apiVersion: database.example.com/v1
kind: MySQL
metadata:
  name: my-database
spec:
  version: "8.0"
  replicas: 3
  storage: "10Gi"
```

##### 3. 控制器实现(伪代码)

```go
func (r *MySQLReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
    // 1. 获取 MySQL 对象
    mysql := &databasev1.MySQL{}
    if err := r.Get(ctx, req.NamespacedName, mysql); err != nil {
        return ctrl.Result{}, client.IgnoreNotFound(err)
    }

    // 2. 确保 StatefulSet 存在
    sts := &appsv1.StatefulSet{}
    if err := r.Get(ctx, req.NamespacedName, sts); err != nil {
        if errors.IsNotFound(err) {
            // 创建 StatefulSet
            sts = r.buildStatefulSet(mysql)
            return ctrl.Result{}, r.Create(ctx, sts)
        }
        return ctrl.Result{}, err
    }

    // 3. 检查副本数是否匹配
    if *sts.Spec.Replicas != mysql.Spec.Replicas {
        sts.Spec.Replicas = &mysql.Spec.Replicas
        return ctrl.Result{}, r.Update(ctx, sts)
    }

    // 4. 执行其他调谐逻辑(备份、监控等)
    return r.reconcileBackup(ctx, mysql)
}
```

### 使用 Kubebuilder 创建 Operator

```bash
# 1. 初始化项目
kubebuilder init --domain example.com --repo github.com/example/myoperator

# 2. 创建 API
kubebuilder create api --group database --version v1 --kind MySQL

# 3. 编辑 types.go 定义 Spec
# 4. 编辑 controller.go 实现 Reconcile 逻辑
# 5. 生成 CRD 和 RBAC
make manifests

# 6. 安装 CRD
make install

# 7. 运行控制器
make run

# 8. 构建镜像并部署
make docker-build docker-push IMG=myregistry/myoperator:v1.0.0
make deploy IMG=myregistry/myoperator:v1.0.0
```

---

## Reconcile 最佳实践

### 1. 幂等性

```go
// ✅ 好的做法:幂等操作
func (r *Reconciler) reconcile(obj *MyResource) error {
    desired := buildDesiredState(obj)
    current := getCurrentState(obj)

    // 只在状态不匹配时才操作
    if !reflect.DeepEqual(desired, current) {
        return r.update(desired)
    }
    return nil
}

// ❌ 坏的做法:每次都创建
func (r *Reconciler) reconcile(obj *MyResource) error {
    // 会导致重复创建
    return r.create(obj)
}
```

### 2. 错误处理和重试

```go
func (r *Reconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
    obj := &MyResource{}
    if err := r.Get(ctx, req.NamespacedName, obj); err != nil {
        // 对象不存在,不重试
        return ctrl.Result{}, client.IgnoreNotFound(err)
    }

    if err := r.reconcile(obj); err != nil {
        if isRetriable(err) {
            // 可重试错误,5 秒后重试
            return ctrl.Result{RequeueAfter: 5 * time.Second}, nil
        }
        // 不可重试错误,记录日志
        return ctrl.Result{}, err
    }

    // 成功,10 分钟后重新调谐
    return ctrl.Result{RequeueAfter: 10 * time.Minute}, nil
}
```

### 3. Finalizer 处理

```go
const myFinalizer = "example.com/finalizer"

func (r *Reconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
    obj := &MyResource{}
    if err := r.Get(ctx, req.NamespacedName, obj); err != nil {
        return ctrl.Result{}, client.IgnoreNotFound(err)
    }

    // 检查是否正在删除
    if !obj.DeletionTimestamp.IsZero() {
        if controllerutil.ContainsFinalizer(obj, myFinalizer) {
            // 执行清理逻辑
            if err := r.cleanup(obj); err != nil {
                return ctrl.Result{}, err
            }

            // 移除 finalizer
            controllerutil.RemoveFinalizer(obj, myFinalizer)
            return ctrl.Result{}, r.Update(ctx, obj)
        }
        return ctrl.Result{}, nil
    }

    // 添加 finalizer
    if !controllerutil.ContainsFinalizer(obj, myFinalizer) {
        controllerutil.AddFinalizer(obj, myFinalizer)
        return ctrl.Result{}, r.Update(ctx, obj)
    }

    // 正常调谐逻辑
    return r.reconcile(obj)
}
```

### 4. Owner Reference

```go
// 设置 Owner Reference,实现级联删除
func (r *Reconciler) createDeployment(owner *MyResource) error {
    deploy := &appsv1.Deployment{
        ObjectMeta: metav1.ObjectMeta{
            Name:      owner.Name,
            Namespace: owner.Namespace,
        },
        Spec: ...,
    }

    // 设置 Owner Reference
    if err := controllerutil.SetControllerReference(owner, deploy, r.Scheme); err != nil {
        return err
    }

    return r.Create(context.TODO(), deploy)
}
```

---

## 常见问题

### Q1: 控制器如何避免无限循环?

**A**: 通过以下机制:
```go
// 1. 对比期望与实际状态,相同则跳过
if reflect.DeepEqual(desired, current) {
    return nil
}

// 2. 使用 Generation/ResourceVersion 检测变化
if obj.Generation == obj.Status.ObservedGeneration {
    return nil
}

// 3. 设置重试间隔和 backoff
return ctrl.Result{RequeueAfter: 5 * time.Minute}, nil
```

### Q2: 如何调试控制器?

**A**:
```bash
# 1. 查看控制器日志
kubectl logs -n kube-system kube-controller-manager-master

# 2. 查看资源事件
kubectl get events --sort-by='.lastTimestamp'

# 3. 查看资源状态
kubectl describe <resource> <name>

# 4. 使用 --v=4 增加日志级别
kubectl logs -n kube-system deployment/my-operator --v=4
```

### Q3: 控制器性能如何优化?

**A**:
```go
// 1. 使用 Informer 缓存,避免频繁调用 API Server
obj, err := informer.Lister().Get(namespace, name)

// 2. 设置合理的并发数
controller.MaxConcurrentReconciles = 5

// 3. 使用 IndexInformer 快速查询
indexer.AddIndexers(cache.Indexers{
    "spec.nodeName": func(obj interface{}) ([]string, error) {
        pod := obj.(*v1.Pod)
        return []string{pod.Spec.NodeName}, nil
    },
})

// 4. 批量处理
func (r *Reconciler) processBatch(items []Item) error {
    // 批量操作
}
```

---

## 总结

- ✅ **控制循环**: Watch → Compare → Reconcile 持续调谐
- ✅ **声明式**: 用户声明期望,控制器自动执行
- ✅ **自愈能力**: 持续监控,自动纠正偏差
- ✅ **内置控制器**: Deployment、StatefulSet、DaemonSet、Job 等
- ✅ **Operator 模式**: CRD + Custom Controller 扩展 K8s 能力
- ✅ **最佳实践**: 幂等性、错误处理、Finalizer、Owner Reference

## 参考资源

- [Kubernetes 控制器概念](https://kubernetes.io/docs/concepts/architecture/controller/)
- [Kubebuilder 文档](https://book.kubebuilder.io/)
- [Operator Pattern](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/)
- [client-go 文档](https://github.com/kubernetes/client-go)
- [controller-runtime](https://github.com/kubernetes-sigs/controller-runtime)

---

*更新日期: 2025-12-03*
