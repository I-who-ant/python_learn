# 网络策略

> NetworkPolicy、Pod 隔离、流量控制

## 概述

【本文档是 Kubernetes 知识体系的一部分】

NetworkPolicy 是 Kubernetes 用于控制 Pod 之间网络流量的资源对象。它类似于云环境中的安全组,通过定义规则来控制哪些 Pod 可以相互通信,哪些流量可以进出 Pod。

## 核心概念

### 什么是 NetworkPolicy

NetworkPolicy 是 Kubernetes 的网络安全机制,主要功能包括:

- **Pod 隔离**: 控制 Pod 的入站(Ingress)和出站(Egress)流量
- **白名单机制**: 默认拒绝,显式允许指定流量
- **多维度选择**: 基于 Pod 标签、命名空间、IP 段进行流量控制
- **协议和端口**: 精确控制到协议(TCP/UDP)和端口级别

### 为什么需要 NetworkPolicy

在生产环境中,我们需要 NetworkPolicy 来解决以下问题:

1. **安全隔离**: 防止未授权的 Pod 间通信
2. **最小权限原则**: 只允许必要的网络访问
3. **多租户隔离**: 不同团队或应用的网络隔离
4. **合规要求**: 满足安全审计和合规性要求
5. **故障隔离**: 限制故障影响范围

### 工作原理

```
默认行为: 所有 Pod 可以自由通信
          ↓
应用 NetworkPolicy
          ↓
匹配的 Pod 进入隔离状态
          ↓
只允许策略中定义的流量
```

**重要**: NetworkPolicy 需要网络插件支持,如 Calico、Cilium、Weave Net 等。

### 流量方向

- **Ingress (入站)**: 进入 Pod 的流量
- **Egress (出站)**: 从 Pod 发出的流量

## 基本使用

### 示例配置

#### 1. 拒绝所有入站流量

```yaml
# deny-all-ingress.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all-ingress
  namespace: default
spec:
  podSelector: {}  # 匹配所有 Pod
  policyTypes:
  - Ingress
```

#### 2. 允许特定 Pod 访问

```yaml
# allow-specific-pods.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-from-frontend
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: backend  # 应用到 backend Pod
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend  # 只允许 frontend Pod 访问
    ports:
    - protocol: TCP
      port: 8080
```

#### 3. 允许特定命名空间访问

```yaml
# allow-from-namespace.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-from-prod
  namespace: database
spec:
  podSelector:
    matchLabels:
      app: mysql
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          env: production  # 只允许 production 命名空间访问
    ports:
    - protocol: TCP
      port: 3306
```

#### 4. 控制出站流量

```yaml
# allow-specific-egress.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-egress-to-dns
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: myapp
  policyTypes:
  - Egress
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: kube-system
      podSelector:
        matchLabels:
          k8s-app: kube-dns
    ports:
    - protocol: UDP
      port: 53
```

#### 5. 允许特定 IP 段访问

```yaml
# allow-from-cidr.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-from-external
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: web
  policyTypes:
  - Ingress
  ingress:
  - from:
    - ipBlock:
        cidr: 192.168.0.0/16  # 允许此 IP 段
        except:
        - 192.168.1.0/24      # 但排除此子网
    ports:
    - protocol: TCP
      port: 80
```

### kubectl 命令

```bash
# 创建 NetworkPolicy
kubectl create -f networkpolicy.yaml
kubectl apply -f networkpolicy.yaml

# 查看 NetworkPolicy
kubectl get networkpolicy
kubectl get netpol

# 查看详细信息
kubectl describe networkpolicy <policy-name>

# 查看所有命名空间的策略
kubectl get networkpolicy --all-namespaces

# 编辑策略
kubectl edit networkpolicy <policy-name>

# 删除策略
kubectl delete networkpolicy <policy-name>

# 导出策略配置
kubectl get networkpolicy <policy-name> -o yaml > policy-backup.yaml

# 测试网络连接
kubectl run test-pod --image=busybox --rm -it -- sh
# 在 Pod 中执行: wget -O- http://service-name:port
```

## 实战案例

### 案例 1: 三层应用隔离

典型的前端-后端-数据库架构:

```yaml
# 1. 数据库层: 只允许后端访问
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: database-policy
  namespace: production
spec:
  podSelector:
    matchLabels:
      tier: database
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          tier: backend
    ports:
    - protocol: TCP
      port: 3306

---
# 2. 后端层: 允许前端访问,可访问数据库
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: backend-policy
  namespace: production
spec:
  podSelector:
    matchLabels:
      tier: backend
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          tier: frontend
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - podSelector:
        matchLabels:
          tier: database
    ports:
    - protocol: TCP
      port: 3306
  # 允许 DNS 查询
  - to:
    - namespaceSelector:
        matchLabels:
          name: kube-system
    ports:
    - protocol: UDP
      port: 53

---
# 3. 前端层: 允许外部访问,可访问后端
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: frontend-policy
  namespace: production
spec:
  podSelector:
    matchLabels:
      tier: frontend
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - ports:
    - protocol: TCP
      port: 80
  egress:
  - to:
    - podSelector:
        matchLabels:
          tier: backend
    ports:
    - protocol: TCP
      port: 8080
  - to:
    - namespaceSelector:
        matchLabels:
          name: kube-system
    ports:
    - protocol: UDP
      port: 53
```

### 案例 2: 命名空间隔离

完全隔离不同环境:

```yaml
# 生产环境命名空间隔离
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-from-other-namespaces
  namespace: production
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector: {}  # 只允许同命名空间内的 Pod 通信

---
# 开发环境可以访问共享服务
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-shared-services
  namespace: development
spec:
  podSelector: {}
  policyTypes:
  - Egress
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: shared-services
  - to:
    - namespaceSelector:
        matchLabels:
          name: kube-system
    ports:
    - protocol: UDP
      port: 53
```

### 案例 3: 微服务通信控制

```yaml
# 允许 API Gateway 访问所有微服务
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: microservices-policy
  namespace: default
spec:
  podSelector:
    matchLabels:
      type: microservice
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: api-gateway
    - podSelector:
        matchLabels:
          type: microservice  # 微服务间可以互相访问
    ports:
    - protocol: TCP
      port: 8080

---
# 限制外部只能访问 API Gateway
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: api-gateway-policy
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: api-gateway
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - ports:  # 允许所有入站流量
    - protocol: TCP
      port: 443
  egress:
  - to:
    - podSelector:
        matchLabels:
          type: microservice
    ports:
    - protocol: TCP
      port: 8080
  - to:  # 允许 DNS
    - namespaceSelector: {}
    ports:
    - protocol: UDP
      port: 53
```

### 案例 4: 默认拒绝 + 白名单

推荐的安全策略:

```yaml
# 步骤 1: 拒绝所有流量
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: default
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress

---
# 步骤 2: 允许必要的 DNS 访问
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dns
  namespace: default
spec:
  podSelector: {}
  policyTypes:
  - Egress
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: kube-system
      podSelector:
        matchLabels:
          k8s-app: kube-dns
    ports:
    - protocol: UDP
      port: 53

---
# 步骤 3: 根据需要添加白名单规则
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-app-traffic
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: myapp
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: client
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: database
    ports:
    - protocol: TCP
      port: 5432
```

### 案例 5: 监控和日志访问控制

```yaml
# 允许 Prometheus 抓取指标
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-prometheus
  namespace: default
spec:
  podSelector:
    matchLabels:
      prometheus-scrape: "true"
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: monitoring
      podSelector:
        matchLabels:
          app: prometheus
    ports:
    - protocol: TCP
      port: 9090

---
# 允许日志收集
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-log-collector
  namespace: default
spec:
  podSelector: {}
  policyTypes:
  - Egress
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: logging
      podSelector:
        matchLabels:
          app: fluentd
    ports:
    - protocol: TCP
      port: 24224
```

## 最佳实践

1. **生产环境建议**
   - 默认拒绝所有流量,然后添加白名单
   - 为每个命名空间配置隔离策略
   - 分别控制 Ingress 和 Egress 流量
   - 使用标签选择器而非硬编码 IP

2. **性能优化**
   - 避免过于复杂的策略规则
   - 合理使用标签选择器
   - 定期清理无用的策略
   - 使用高性能网络插件(Cilium)

3. **安全加固**
   - 实施最小权限原则
   - 定期审计网络策略
   - 监控异常的网络连接
   - 结合 Pod Security Policy 使用

4. **开发和调试**
   - 先在测试环境验证策略
   - 使用专门的 Pod 测试连通性
   - 保留详细的策略文档
   - 使用工具可视化网络策略

5. **策略管理**
   - 使用 GitOps 管理策略配置
   - 为策略添加清晰的注释
   - 版本控制所有策略文件
   - 定期备份策略配置

## 网络插件支持

### Calico

最流行的支持 NetworkPolicy 的网络插件:

```bash
# 安装 Calico
kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml

# 查看 Calico 状态
kubectl get pods -n kube-system | grep calico

# 查看网络策略(Calico 增强)
kubectl get networkpolicies
calicoctl get networkpolicies
```

Calico 扩展功能:
- 支持全局网络策略
- 支持更精细的规则
- 提供网络流量可视化

### Cilium

基于 eBPF 的高性能网络方案:

```bash
# 使用 Helm 安装 Cilium
helm repo add cilium https://helm.cilium.io/
helm install cilium cilium/cilium --namespace kube-system

# 查看状态
cilium status
```

Cilium 特性:
- 基于 eBPF,性能更高
- 支持 Layer 7 策略
- 提供 Hubble 可视化

## 常见问题

### Q1: NetworkPolicy 不生效?

A: 检查以下几点:
1. 网络插件是否支持 NetworkPolicy
   ```bash
   kubectl get pods -n kube-system
   # 查看是否有 Calico、Cilium 等
   ```
2. 策略的 podSelector 是否正确匹配
3. 策略是否在正确的命名空间
4. policyTypes 是否正确指定

### Q2: 如何测试网络策略?

A: 使用测试 Pod:
```bash
# 创建测试 Pod
kubectl run test-client --image=busybox --rm -it -- sh

# 在 Pod 中测试连接
wget -O- http://service-name:port --timeout=2

# 测试 DNS
nslookup service-name

# 测试 TCP 连接
telnet service-name port
```

### Q3: 应用 NetworkPolicy 后服务不可访问?

A: 常见原因:
- 忘记允许 DNS 流量(UDP 53)
- Egress 规则过于严格
- 端口配置错误
- 标签选择器不匹配

解决方法:
```bash
# 查看策略详情
kubectl describe networkpolicy <policy-name>

# 查看 Pod 标签
kubectl get pods --show-labels

# 临时删除策略测试
kubectl delete networkpolicy <policy-name>
```

### Q4: NetworkPolicy 和防火墙的区别?

A:
- **NetworkPolicy**: Pod 级别的网络控制,工作在集群内部
- **防火墙**: 节点或网络级别,控制集群外部流量

推荐: 两者结合使用,提供纵深防御

### Q5: 如何可视化网络策略?

A: 使用工具:
1. **Cilium Hubble**: 图形化显示网络流量
2. **Calico Enterprise**: 提供策略可视化
3. **Tufin**: 第三方网络策略管理工具
4. **kubectl-graph**: 生成策略关系图

```bash
# 使用 kubectl-graph
kubectl graph networkpolicy -n default
```

## 调试技巧

### 1. 查看网络流量

使用 tcpdump:
```bash
# 在节点上抓包
tcpdump -i any host <pod-ip> -nn

# 在 Pod 中抓包(需要特权容器)
kubectl exec -it <pod> -- tcpdump -nn
```

### 2. 检查连接

```bash
# 从 Pod A 测试到 Pod B
kubectl exec -it pod-a -- curl http://pod-b-service:8080

# 检查 DNS 解析
kubectl exec -it pod-a -- nslookup pod-b-service

# 检查端口连通性
kubectl exec -it pod-a -- nc -zv pod-b-ip 8080
```

### 3. 查看策略覆盖

```bash
# 查看哪些 Pod 被策略覆盖
kubectl get pods -l app=myapp --show-labels

# 查看命名空间的所有策略
kubectl get networkpolicy -n <namespace>

# 导出所有策略进行分析
kubectl get networkpolicy --all-namespaces -o yaml > all-policies.yaml
```

## 总结

- ✅ 理解 NetworkPolicy 的概念和工作原理
- ✅ 掌握 Ingress 和 Egress 流量控制
- ✅ 理解 Pod、命名空间、IP 段选择器
- ✅ 掌握常见应用场景的策略配置
- ✅ 了解网络插件的选择和配置
- ✅ 能够排查网络策略相关问题

## 参考资源

- [Kubernetes NetworkPolicy 官方文档](https://kubernetes.io/docs/concepts/services-networking/network-policies/)
- [Calico NetworkPolicy 文档](https://docs.projectcalico.org/security/network-policy)
- [Cilium NetworkPolicy 文档](https://docs.cilium.io/en/stable/policy/)
- [NetworkPolicy Editor](https://editor.cilium.io/) - 在线策略编辑器

---

*更新日期: 2025-12-03*
