# 网络策略

> 网络隔离、入站出站规则

## 概述

【本文档是 Kubernetes 知识体系的一部分】

**网络策略(NetworkPolicy)是 Kubernetes 实现 Pod 间网络隔离的关键机制**。通过定义入站(Ingress)和出站(Egress)规则,可以精细控制 Pod 之间的网络流量,实现微服务间的访问控制,防止横向攻击和数据泄露。

## 核心概念

### 什么是网络策略

NetworkPolicy 是 Kubernetes 的网络访问控制列表(ACL):

| 组件 | 说明 | 作用 |
|-----|------|------|
| **NetworkPolicy** | 网络策略对象 | 定义流量规则 |
| **podSelector** | Pod 选择器 | 指定规则应用的 Pod |
| **Ingress** | 入站规则 | 控制进入 Pod 的流量 |
| **Egress** | 出站规则 | 控制离开 Pod 的流量 |
| **CNI 插件** | 网络插件 | 实际执行策略(Calico、Cilium 等) |

### 网络策略类型

| 规则类型 | 说明 | 示例 |
|---------|------|------|
| **Ingress** | 入站流量控制 | 只允许来自特定 Pod 的请求 |
| **Egress** | 出站流量控制 | 只允许访问特定数据库 |
| **Ingress + Egress** | 双向控制 | 完全隔离 Pod |

### 为什么需要网络策略

| 安全问题 | 后果 | NetworkPolicy 防护 |
|---------|------|------------------|
| **横向移动攻击** | 攻陷一个 Pod 后访问其他服务 | 限制 Pod 间通信 |
| **数据泄露** | Pod 访问外部恶意地址 | 限制出站流量 |
| **未授权访问** | 任意 Pod 访问数据库 | 只允许特定 Pod 访问 |
| **多租户隔离** | 不同团队的 Pod 互相访问 | Namespace 级别隔离 |

---

## NetworkPolicy 前提条件

### 1. CNI 插件支持

**支持 NetworkPolicy 的 CNI 插件**:

| CNI 插件 | 支持程度 | 说明 |
|---------|---------|------|
| **Calico** | ✅ 完全支持 | 功能最强大,支持扩展策略 |
| **Cilium** | ✅ 完全支持 | 基于 eBPF,性能高 |
| **Weave Net** | ✅ 完全支持 | 简单易用 |
| **Canal** | ✅ 完全支持 | Flannel + Calico |
| **Flannel** | ❌ 不支持 | 仅提供网络连通性 |
| **Kube-router** | ✅ 完全支持 | IPVS 模式 |

### 2. 检查 CNI 插件

```bash
# 查看当前 CNI 插件
kubectl get pods -n kube-system | grep -E 'calico|cilium|weave|flannel'

# 查看节点网络配置
ls /etc/cni/net.d/

# 测试 NetworkPolicy 是否生效
kubectl apply -f - <<EOF
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: test-network-policy
  namespace: default
spec:
  podSelector: {}
  policyTypes:
  - Ingress
EOF

kubectl get networkpolicy -n default
```

---

## NetworkPolicy 基础

### 1. 默认行为

**没有 NetworkPolicy 时**:
- 所有 Pod 可以互相通信
- 所有 Pod 可以访问外部网络
- 外部可以访问 Pod(通过 Service)

**创建 NetworkPolicy 后**:
- 默认拒绝所有未明确允许的流量
- 需要显式定义允许的流量

### 2. 基本结构

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: example-policy
  namespace: default
spec:
  # 选择应用策略的 Pod
  podSelector:
    matchLabels:
      app: myapp

  # 策略类型
  policyTypes:
  - Ingress  # 入站规则
  - Egress   # 出站规则

  # 入站规则
  ingress:
  - from:
    - podSelector:
        matchLabels:
          role: frontend
    ports:
    - protocol: TCP
      port: 80

  # 出站规则
  egress:
  - to:
    - podSelector:
        matchLabels:
          role: database
    ports:
    - protocol: TCP
      port: 3306
```

---

## Ingress(入站)规则

### 1. 拒绝所有入站流量

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all-ingress
  namespace: default
spec:
  podSelector: {}  # 选择所有 Pod
  policyTypes:
  - Ingress
  # ingress: []  # 空规则 = 拒绝所有
```

**效果**: 所有 Pod 无法接收任何入站流量。

### 2. 允许特定 Pod 访问

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-frontend
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: backend  # 应用到 backend Pod
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend  # 只允许 frontend Pod 访问
    ports:
    - protocol: TCP
      port: 8080
```

**说明**:
- `podSelector` 为空: 匹配同一 Namespace 的所有 Pod
- 可以组合多个选择器

### 3. 允许特定 Namespace 访问

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-from-namespace
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: api
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          env: production  # 只允许标签为 env=production 的 Namespace
    ports:
    - protocol: TCP
      port: 443
```

### 4. 允许特定 IP 段访问

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-from-cidr
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: web
  policyTypes:
  - Ingress
  ingress:
  - from:
    - ipBlock:
        cidr: 192.168.1.0/24  # 允许的 IP 段
        except:
        - 192.168.1.5/32      # 排除特定 IP
    ports:
    - protocol: TCP
      port: 80
```

### 5. 组合多个来源

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-multiple-sources
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: database
  policyTypes:
  - Ingress
  ingress:
  # 规则 1: 允许同 Namespace 的特定 Pod
  - from:
    - podSelector:
        matchLabels:
          role: backend
    ports:
    - protocol: TCP
      port: 3306

  # 规则 2: 允许特定 Namespace 的所有 Pod
  - from:
    - namespaceSelector:
        matchLabels:
          env: production
    ports:
    - protocol: TCP
      port: 3306
```

---

## Egress(出站)规则

### 1. 拒绝所有出站流量

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all-egress
  namespace: default
spec:
  podSelector: {}
  policyTypes:
  - Egress
  # egress: []  # 拒绝所有出站
```

### 2. 允许访问特定 Pod

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-to-database
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes:
  - Egress
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: mysql
    ports:
    - protocol: TCP
      port: 3306
```

### 3. 允许 DNS 查询

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dns
  namespace: default
spec:
  podSelector: {}
  policyTypes:
  - Egress
  egress:
  # DNS 查询(kube-dns/CoreDNS)
  - to:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: kube-system
    - podSelector:
        matchLabels:
          k8s-app: kube-dns
    ports:
    - protocol: UDP
      port: 53
```

### 4. 允许访问外部 API

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-external-api
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: webapp
  policyTypes:
  - Egress
  egress:
  # 允许 DNS
  - to:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: kube-system
    ports:
    - protocol: UDP
      port: 53

  # 允许访问外部 API
  - to:
    - ipBlock:
        cidr: 0.0.0.0/0
        except:
        - 169.254.169.254/32  # 排除云厂商元数据服务
    ports:
    - protocol: TCP
      port: 443
```

---

## 实战案例

### 案例 1: 三层架构隔离

**架构**: Frontend → Backend → Database

```yaml
# 1. Database: 只允许 Backend 访问
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: database-policy
  namespace: production
spec:
  podSelector:
    matchLabels:
      tier: database
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # 只允许 Backend 访问
  - from:
    - podSelector:
        matchLabels:
          tier: backend
    ports:
    - protocol: TCP
      port: 3306
  egress:
  # 允许 DNS
  - to:
    - namespaceSelector: {}
      podSelector:
        matchLabels:
          k8s-app: kube-dns
    ports:
    - protocol: UDP
      port: 53

---
# 2. Backend: 允许 Frontend 访问,可以访问 Database
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: backend-policy
  namespace: production
spec:
  podSelector:
    matchLabels:
      tier: backend
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # 允许 Frontend 访问
  - from:
    - podSelector:
        matchLabels:
          tier: frontend
    ports:
    - protocol: TCP
      port: 8080
  egress:
  # 允许访问 Database
  - to:
    - podSelector:
        matchLabels:
          tier: database
    ports:
    - protocol: TCP
      port: 3306
  # 允许 DNS
  - to:
    - namespaceSelector: {}
      podSelector:
        matchLabels:
          k8s-app: kube-dns
    ports:
    - protocol: UDP
      port: 53

---
# 3. Frontend: 允许外部访问,可以访问 Backend
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: frontend-policy
  namespace: production
spec:
  podSelector:
    matchLabels:
      tier: frontend
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # 允许所有入站(通过 Ingress Controller)
  - {}
  egress:
  # 允许访问 Backend
  - to:
    - podSelector:
        matchLabels:
          tier: backend
    ports:
    - protocol: TCP
      port: 8080
  # 允许 DNS
  - to:
    - namespaceSelector: {}
      podSelector:
        matchLabels:
          k8s-app: kube-dns
    ports:
    - protocol: UDP
      port: 53
```

**测试**:

```bash
# 部署测试 Pod
kubectl run frontend --image=curlimages/curl --labels=tier=frontend -n production -- sleep 3600
kubectl run backend --image=curlimages/curl --labels=tier=backend -n production -- sleep 3600
kubectl run database --image=curlimages/curl --labels=tier=database -n production -- sleep 3600

# Frontend 可以访问 Backend
kubectl exec -it frontend -n production -- curl http://backend:8080
# 成功

# Frontend 不能直接访问 Database
kubectl exec -it frontend -n production -- curl http://database:3306
# 超时/拒绝

# Backend 可以访问 Database
kubectl exec -it backend -n production -- curl http://database:3306
# 成功
```

### 案例 2: Namespace 隔离

```yaml
# 1. 为 Namespace 添加标签
kubectl label namespace production env=production
kubectl label namespace development env=development
kubectl label namespace testing env=testing

---
# 2. Production 只允许内部通信
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-cross-namespace
  namespace: production
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # 只允许同 Namespace 的 Pod
  - from:
    - podSelector: {}
  egress:
  # 只允许访问同 Namespace 的 Pod
  - to:
    - podSelector: {}
  # 允许 DNS(kube-system)
  - to:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: kube-system
    ports:
    - protocol: UDP
      port: 53
  # 允许访问外部(HTTPS)
  - to:
    - ipBlock:
        cidr: 0.0.0.0/0
    ports:
    - protocol: TCP
      port: 443
```

### 案例 3: 只允许 Ingress Controller 访问

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-from-ingress
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: web
  policyTypes:
  - Ingress
  ingress:
  - from:
    # 允许来自 ingress-nginx Namespace 的流量
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: ingress-nginx
      podSelector:
        matchLabels:
          app.kubernetes.io/name: ingress-nginx
    ports:
    - protocol: TCP
      port: 80
```

### 案例 4: 限制出站到特定域名(Cilium)

```yaml
# 注意: 需要 Cilium CNI
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: allow-specific-domain
  namespace: default
spec:
  endpointSelector:
    matchLabels:
      app: myapp
  egress:
  # 允许 DNS
  - toEndpoints:
    - matchLabels:
        k8s:io.kubernetes.pod.namespace: kube-system
        k8s-app: kube-dns
    toPorts:
    - ports:
      - port: "53"
        protocol: UDP

  # 允许访问特定域名
  - toFQDNs:
    - matchName: "api.github.com"
    - matchPattern: "*.example.com"
    toPorts:
    - ports:
      - port: "443"
        protocol: TCP
```

---

## 最佳实践

### 1. 默认拒绝策略

```yaml
# ✅ 推荐: 先拒绝所有,再逐步开放
---
# 拒绝所有入站
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-ingress
  namespace: production
spec:
  podSelector: {}
  policyTypes:
  - Ingress

---
# 拒绝所有出站
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-egress
  namespace: production
spec:
  podSelector: {}
  policyTypes:
  - Egress

---
# 然后创建允许规则
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-specific
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: myapp
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: database
```

### 2. 始终允许 DNS

```yaml
# ✅ 推荐: 所有 Pod 都需要 DNS 解析
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dns-access
  namespace: production
spec:
  podSelector: {}
  policyTypes:
  - Egress
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: kube-system
    ports:
    - protocol: UDP
      port: 53
    - protocol: TCP
      port: 53
```

### 3. 为 Namespace 添加标签

```bash
# ✅ 推荐: 便于策略引用
kubectl label namespace production env=production
kubectl label namespace kube-system kubernetes.io/metadata.name=kube-system
```

### 4. 使用有意义的策略名称

```yaml
# ✅ 推荐: 清晰的命名
name: allow-frontend-to-backend
name: deny-external-egress
name: allow-monitoring-scrape

# ❌ 不推荐: 模糊的命名
name: policy-1
name: network-policy
name: test
```

### 5. 逐步迁移

```bash
# 1. 创建审计策略(使用 policyTypes 但不定义规则)
# 2. 监控日志,识别必要的流量
# 3. 添加允许规则
# 4. 启用拒绝策略
```

---

## 常见问题

### Q1: NetworkPolicy 不生效怎么办?

**A**:

```bash
# 1. 检查 CNI 插件是否支持
kubectl get pods -n kube-system | grep -E 'calico|cilium|weave'

# 2. 检查策略是否创建成功
kubectl get networkpolicy -n production
kubectl describe networkpolicy allow-frontend -n production

# 3. 查看 CNI 日志
kubectl logs -n kube-system -l k8s-app=calico-node

# 4. 测试连接
kubectl run test --image=curlimages/curl -it --rm -- curl http://backend:8080
```

### Q2: 如何查看 Pod 应用了哪些策略?

**A**:

```bash
# 方法 1: 查看所有策略
kubectl get networkpolicies -n production

# 方法 2: 查看策略详情
kubectl describe networkpolicy -n production

# 方法 3: 使用标签过滤
kubectl get networkpolicies -n production -o yaml | grep -A 10 "podSelector"

# 方法 4: 使用工具可视化
# 安装 kubectl-netpol 插件
kubectl krew install netpol
kubectl netpol check pod-name -n production
```

### Q3: 如何调试 NetworkPolicy?

**A**:

```bash
# 1. 创建测试 Pod
kubectl run client --image=curlimages/curl -n production -- sleep 3600
kubectl run server --image=nginx:1.21 -n production --labels=app=server

# 2. 测试连接
kubectl exec -it client -n production -- curl http://server

# 3. 查看策略
kubectl get networkpolicy -n production -o yaml

# 4. 使用 Calico 的策略诊断工具
kubectl exec -it -n kube-system calico-node-xxx -- calicoctl get networkpolicy -o yaml

# 5. 查看 iptables 规则(需要节点访问权限)
iptables-save | grep KUBE
```

### Q4: NetworkPolicy 和 Service 的关系?

**A**:

NetworkPolicy 是基于 **Pod IP** 的,不是基于 Service:

```yaml
# ❌ 错误: 不能直接引用 Service
egress:
- to:
  - service: backend-service  # 无效

# ✅ 正确: 使用 podSelector 选择 Service 后端的 Pod
egress:
- to:
  - podSelector:
      matchLabels:
        app: backend  # Service 的 selector
```

### Q5: 如何允许 Prometheus 抓取指标?

**A**:

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-prometheus-scrape
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: myapp
  policyTypes:
  - Ingress
  ingress:
  # 允许 Prometheus 访问 /metrics
  - from:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: monitoring
      podSelector:
        matchLabels:
          app: prometheus
    ports:
    - protocol: TCP
      port: 8080  # metrics 端口
```

---

## 调试工具

### 1. kubectl-netpol 插件

```bash
# 安装
kubectl krew install netpol

# 检查 Pod 的网络策略
kubectl netpol check frontend -n production

# 可视化策略
kubectl netpol visualize -n production
```

### 2. Calico calicoctl

```bash
# 查看 Calico 策略
kubectl exec -n kube-system calico-node-xxx -- calicoctl get networkpolicy -o yaml

# 查看策略详情
kubectl exec -n kube-system calico-node-xxx -- calicoctl get networkpolicy allow-frontend -o yaml

# 查看生效的策略
kubectl exec -n kube-system calico-node-xxx -- calicoctl get workloadendpoint -o wide
```

### 3. Cilium CLI

```bash
# 查看策略
cilium policy get

# 查看策略执行情况
cilium monitor --type policy-verdict

# 查看 DNS 解析
cilium monitor --type l7
```

---

## 总结

- ✅ **NetworkPolicy**: 实现 Pod 间网络隔离的关键机制
- ✅ **CNI 插件**: 需要支持 NetworkPolicy 的 CNI(Calico、Cilium 等)
- ✅ **默认拒绝**: 生产环境推荐默认拒绝所有流量,再逐步开放
- ✅ **Ingress 规则**: 控制进入 Pod 的流量
- ✅ **Egress 规则**: 控制离开 Pod 的流量
- ✅ **DNS 访问**: 大部分 Pod 都需要允许 DNS 查询
- ✅ **标签选择器**: 使用 podSelector、namespaceSelector 精确匹配

## 参考资源

- [Network Policies 官方文档](https://kubernetes.io/docs/concepts/services-networking/network-policies/)
- [Declare Network Policy](https://kubernetes.io/docs/tasks/administer-cluster/declare-network-policy/)
- [Calico Network Policy](https://docs.projectcalico.org/security/calico-network-policy)
- [Cilium Network Policy](https://docs.cilium.io/en/stable/policy/)
- [NetworkPolicy Editor](https://editor.cilium.io/)
- [NetworkPolicy Recipes](https://github.com/ahmetb/kubernetes-network-policy-recipes)

---

*更新日期: 2025-12-03*
