# 调度器原理

> 调度流程、预选、优选、绑定

## 概述

【本文档是 Kubernetes 知识体系的一部分】

Kubernetes 调度器 (kube-scheduler) 负责将 Pod 分配到合适的节点上运行。理解调度器的工作原理对于优化集群资源利用和应用性能至关重要。

## 核心概念

### 什么是调度器

调度器是 Kubernetes 控制平面的核心组件,负责监听新创建的 Pod 并为其选择最佳的运行节点。

**核心功能:**
- **节点选择**: 为 Pod 选择合适的节点
- **资源匹配**: 确保节点有足够资源
- **约束满足**: 满足各种调度约束
- **负载均衡**: 合理分配集群负载

### 为什么需要

在生产环境中,调度器帮助我们:

1. **资源优化**: 充分利用集群资源
2. **性能保证**: 将 Pod 调度到合适的节点
3. **高可用**: 分散 Pod 避免单点故障
4. **满足约束**: 符合亲和性、污点容忍等规则

### 调度器架构

```
┌─────────────────────────────────────────┐
│           kube-scheduler                │
│                                         │
│  ┌───────────┐      ┌────────────┐     │
│  │  调度队列  │ ───→ │  调度周期   │     │
│  └───────────┘      └────────────┘     │
│                           │             │
│                           ↓             │
│       ┌───────────────────────────┐    │
│       │    调度流程                │    │
│       │  1. 预选 (Filtering)      │    │
│       │  2. 优选 (Scoring)        │    │
│       │  3. 绑定 (Binding)        │    │
│       └───────────────────────────┘    │
└─────────────────────────────────────────┘
```

## 调度流程

### 完整流程

```
                    [新建 Pod]
                        ↓
                  [进入调度队列]
                        ↓
            ┌──────────────────────┐
            │   1. 预选阶段         │
            │   (Filtering)        │
            │   过滤不满足的节点     │
            └──────────────────────┘
                        ↓
                  [可行节点列表]
                        ↓
            ┌──────────────────────┐
            │   2. 优选阶段         │
            │   (Scoring)          │
            │   为节点打分排序      │
            └──────────────────────┘
                        ↓
                  [最佳节点]
                        ↓
            ┌──────────────────────┐
            │   3. 绑定阶段         │
            │   (Binding)          │
            │   将 Pod 绑定到节点   │
            └──────────────────────┘
                        ↓
                  [调度完成]
```

### 1. 预选阶段 (Filtering)

过滤掉不满足条件的节点。

**常见预选策略:**

```yaml
# 节点资源充足
- PodFitsResources: 节点有足够的 CPU、内存

# 端口不冲突
- PodFitsHostPorts: hostPort 未被占用

# 节点选择器匹配
- NodeSelector: 匹配 nodeSelector

# 节点名称匹配
- PodMatchNodeName: nodeName 匹配

# 污点容忍
- TaintToleration: Pod 容忍节点污点

# 卷匹配
- VolumeBinding: PVC 可以绑定

# 节点亲和性
- NodeAffinity: 满足节点亲和性规则

# Pod 拓扑分布
- PodTopologySpread: 满足拓扑分布约束
```

**示例: Pod 资源请求**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: resource-demo
spec:
  containers:
  - name: app
    image: nginx
    resources:
      requests:
        memory: "1Gi"
        cpu: "500m"
```

预选逻辑:
```
节点A: 可用内存 2Gi, CPU 1核  ✅ 通过
节点B: 可用内存 512Mi, CPU 2核 ❌ 内存不足
节点C: 可用内存 4Gi, CPU 200m  ❌ CPU不足
```

### 2. 优选阶段 (Scoring)

为通过预选的节点打分,选择最佳节点。

**常见优选策略:**

```yaml
# 最少请求资源
- LeastRequestedPriority: 资源使用率低的节点得分高
  公式: score = (capacity - requested) / capacity * 10

# 最均衡资源
- BalancedResourceAllocation: CPU和内存使用均衡
  公式: score = 10 - abs(cpuFraction - memoryFraction) * 10

# 节点亲和性
- NodeAffinityPriority: 满足亲和性得分高

# Pod 亲和性
- InterPodAffinityPriority: 满足 Pod 亲和性

# 最少 Pod
- MostRequestedPriority: Pod 数量少的节点

# 镜像本地性
- ImageLocalityPriority: 已有镜像的节点得分高
```

**示例: 节点打分**
```
假设 3 个节点通过预选:

节点A:
  - CPU使用率: 30% (score: 7)
  - 内存使用率: 40% (score: 6)
  - 总分: 13

节点B:
  - CPU使用率: 60% (score: 4)
  - 内存使用率: 50% (score: 5)
  - 总分: 9

节点C:
  - CPU使用率: 20% (score: 8)
  - 内存使用率: 25% (score: 7.5)
  - 总分: 15.5

选择: 节点C (得分最高)
```

### 3. 绑定阶段 (Binding)

将 Pod 绑定到选定的节点。

```yaml
# 绑定对象
apiVersion: v1
kind: Binding
metadata:
  name: my-pod
target:
  apiVersion: v1
  kind: Node
  name: node-1
```

**绑定流程:**
```
1. 调度器创建 Binding 对象
2. API Server 接收绑定请求
3. 更新 Pod 的 spec.nodeName
4. kubelet 监听到 Pod 分配
5. kubelet 创建并启动容器
```

## 调度策略

### 资源请求调度

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: resource-pod
spec:
  containers:
  - name: app
    image: nginx
    resources:
      requests:
        memory: "256Mi"
        cpu: "250m"
      limits:
        memory: "512Mi"
        cpu: "500m"
```

调度器只考虑 `requests`,不考虑 `limits`。

### 节点选择器

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: node-selector-pod
spec:
  nodeSelector:
    disktype: ssd
    zone: us-east-1a
  containers:
  - name: app
    image: nginx
```

只有带有匹配标签的节点才能通过预选。

### 节点名称

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: node-name-pod
spec:
  nodeName: node-1  # 直接指定节点,跳过调度器
  containers:
  - name: app
    image: nginx
```

### 节点亲和性

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: affinity-pod
spec:
  affinity:
    nodeAffinity:
      # 硬性要求
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: kubernetes.io/hostname
            operator: In
            values:
            - node-1
            - node-2

      # 偏好设置
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        preference:
          matchExpressions:
          - key: disktype
            operator: In
            values:
            - ssd
  containers:
  - name: app
    image: nginx
```

## 调度器配置

### 查看调度器配置

```bash
# 查看调度器 Pod
kubectl get pods -n kube-system -l component=kube-scheduler

# 查看调度器日志
kubectl logs -n kube-system kube-scheduler-<name>

# 查看调度器配置
kubectl get configmap -n kube-system kube-scheduler-config -o yaml
```

### 自定义调度策略

```yaml
apiVersion: kubescheduler.config.k8s.io/v1
kind: KubeSchedulerConfiguration
profiles:
- schedulerName: default-scheduler
  plugins:
    # 预选插件
    filter:
      enabled:
      - name: NodeResourcesFit
      - name: NodePorts
      - name: PodTopologySpread

    # 优选插件
    score:
      enabled:
      - name: NodeResourcesBalancedAllocation
        weight: 1
      - name: ImageLocality
        weight: 1
      - name: InterPodAffinity
        weight: 2
      - name: NodeAffinity
        weight: 2

    # 绑定插件
    bind:
      enabled:
      - name: DefaultBinder
```

### 多调度器

```yaml
# 自定义调度器 Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-scheduler
  namespace: kube-system
spec:
  replicas: 1
  selector:
    matchLabels:
      component: my-scheduler
  template:
    metadata:
      labels:
        component: my-scheduler
    spec:
      serviceAccountName: my-scheduler
      containers:
      - name: scheduler
        image: k8s.gcr.io/kube-scheduler:v1.28.0
        command:
        - kube-scheduler
        - --config=/etc/kubernetes/my-scheduler-config.yaml
        - --scheduler-name=my-scheduler
        volumeMounts:
        - name: config
          mountPath: /etc/kubernetes
      volumes:
      - name: config
        configMap:
          name: my-scheduler-config
---
# 使用自定义调度器
apiVersion: v1
kind: Pod
metadata:
  name: custom-scheduled-pod
spec:
  schedulerName: my-scheduler  # 指定调度器
  containers:
  - name: app
    image: nginx
```

## 实战案例

### 案例 1: 高性能应用调度

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: high-performance-app
spec:
  # 节点选择: SSD + 高性能 CPU
  nodeSelector:
    disktype: ssd
    cpu-type: high-performance

  # 亲和性: 偏好内存大的节点
  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        preference:
          matchExpressions:
          - key: memory-size
            operator: In
            values:
            - large
            - xlarge

  # 资源保证
  containers:
  - name: app
    image: high-perf-app:latest
    resources:
      requests:
        memory: "4Gi"
        cpu: "2000m"
      limits:
        memory: "8Gi"
        cpu: "4000m"
```

### 案例 2: 跨可用区部署

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: multi-zone-app
spec:
  replicas: 6
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      # Pod 反亲和性: 分散到不同节点
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app
                operator: In
                values:
                - myapp
            topologyKey: kubernetes.io/hostname

      # 拓扑分布: 均匀分布到不同可用区
      topologySpreadConstraints:
      - maxSkew: 1
        topologyKey: topology.kubernetes.io/zone
        whenUnsatisfiable: DoNotSchedule
        labelSelector:
          matchLabels:
            app: myapp

      containers:
      - name: app
        image: myapp:latest
```

### 案例 3: GPU 工作负载

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: gpu-workload
spec:
  # 节点选择: 带 GPU
  nodeSelector:
    accelerator: nvidia-tesla-v100

  # 容忍 GPU 节点污点
  tolerations:
  - key: nvidia.com/gpu
    operator: Exists
    effect: NoSchedule

  containers:
  - name: cuda-app
    image: nvidia/cuda:11.0-base
    resources:
      limits:
        nvidia.com/gpu: 1  # 请求 1 个 GPU
    command:
    - nvidia-smi
```

### 案例 4: 调度失败排查

```bash
# 查看 Pod 调度状态
kubectl get pods
kubectl describe pod pending-pod

# 常见失败原因:
# 1. 资源不足
#    Event: 0/3 nodes are available: insufficient cpu

# 2. 节点选择器不匹配
#    Event: 0/3 nodes are available: node(s) didn't match node selector

# 3. 污点不容忍
#    Event: 0/3 nodes are available: node(s) had taint

# 4. 亲和性不满足
#    Event: 0/3 nodes are available: node(s) didn't match pod affinity rules

# 查看节点资源
kubectl describe nodes

# 查看节点标签
kubectl get nodes --show-labels

# 查看节点污点
kubectl describe nodes | grep Taints
```

## 调度器性能优化

### 1. 减少调度延迟

```yaml
# 调度器配置
apiVersion: kubescheduler.config.k8s.io/v1
kind: KubeSchedulerConfiguration
profiles:
- schedulerName: default-scheduler
  # 并发调度
  percentageOfNodesToScore: 50  # 只考虑 50% 的节点
```

### 2. 批量调度

```yaml
# 使用 PriorityClass
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000000
globalDefault: false
description: "高优先级任务"
---
apiVersion: v1
kind: Pod
metadata:
  name: priority-pod
spec:
  priorityClassName: high-priority
  containers:
  - name: app
    image: nginx
```

### 3. 预选缓存

调度器会缓存节点信息,减少 API 调用:
```
- 节点列表缓存: 30s
- 节点资源缓存: 30s
- Pod 列表缓存: 30s
```

## 最佳实践

### 1. 合理设置资源请求

```yaml
resources:
  requests:
    memory: "256Mi"  # 基于实际使用设置
    cpu: "250m"
  limits:
    memory: "512Mi"  # 留有余量
    cpu: "500m"
```

### 2. 使用亲和性而非节点选择器

```yaml
# ❌ 硬编码节点
nodeSelector:
  kubernetes.io/hostname: node-1

# ✅ 使用亲和性
affinity:
  nodeAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      preference:
        matchExpressions:
        - key: zone
          operator: In
          values:
          - us-east-1a
```

### 3. 设置 Pod 优先级

```yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: critical-app
value: 1000000
preemptionPolicy: PreemptLowerPriority
```

### 4. 拓扑分布约束

```yaml
topologySpreadConstraints:
- maxSkew: 1
  topologyKey: topology.kubernetes.io/zone
  whenUnsatisfiable: DoNotSchedule
  labelSelector:
    matchLabels:
      app: myapp
```

## 常见问题

### Q1: Pod 一直处于 Pending 状态?

**排查步骤:**
```bash
kubectl describe pod <pod-name>
```

查看 Events 部分的错误信息。

### Q2: 如何查看调度决策?

```bash
# 查看调度器日志
kubectl logs -n kube-system -l component=kube-scheduler

# 开启详细日志
--v=5  # 日志级别
```

### Q3: 如何强制重新调度?

```bash
# 删除 Pod 让调度器重新调度
kubectl delete pod <pod-name>

# 或者驱逐节点上的 Pod
kubectl drain <node-name>
```

### Q4: 自定义调度器如何调试?

```bash
# 查看自定义调度器日志
kubectl logs -n kube-system -l component=my-scheduler

# 确认 Pod 使用了正确的调度器
kubectl get pod <pod-name> -o jsonpath='{.spec.schedulerName}'
```

## 总结

- ✅ 理解调度器的三阶段流程 (预选、优选、绑定)
- ✅ 掌握常见的调度策略和配置
- ✅ 能够使用亲和性、污点容忍等高级特性
- ✅ 了解调度器性能优化方法
- ✅ 能够排查和解决调度问题

## 参考资源

- [调度器官方文档](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/kube-scheduler/)
- [调度框架](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/scheduling-framework/)
- [调度策略](https://kubernetes.io/zh-cn/docs/reference/scheduling/policies/)
- [调度器配置](https://kubernetes.io/zh-cn/docs/reference/scheduling/config/)

---

*更新日期: 2025-12-03*
