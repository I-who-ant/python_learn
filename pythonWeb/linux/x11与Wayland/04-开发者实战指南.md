# X11 ä¸ Wayland å¼€å‘è€…å®æˆ˜æŒ‡å—

## ğŸ¯ æœ¬æ–‡ç›®æ ‡

æä¾›å®ç”¨çš„è°ƒè¯•æŠ€å·§ã€å¸¸è§é—®é¢˜è§£å†³æ–¹æ¡ˆå’Œè¿ç§»æŒ‡å—,å¸®åŠ©ä½ åœ¨å®é™…å¼€å‘ä¸­é«˜æ•ˆå¤„ç† X11 å’Œ Wayland ç›¸å…³é—®é¢˜ã€‚

---

## ğŸ” è°ƒè¯•å·¥å…·ç®±

### X11 è°ƒè¯•å·¥å…·

#### 1. xev - äº‹ä»¶ç›‘è§†å™¨

```bash
# ç›‘å¬æ‰€æœ‰ X11 äº‹ä»¶
xev

# è¾“å‡ºç¤ºä¾‹:
KeyPress event, serial 37, synthetic NO, window 0x3a00001,
    root 0x2b1, subw 0x0, time 4249473, (144,83), root:(155,104),
    state 0x0, keycode 38 (keysym 0x61, a), same_screen YES,
    XLookupString gives 1 bytes: (61) "a"

# æŒ‰ä¸‹é”®ç›˜æ—¶ä¼šæ˜¾ç¤ºè¯¦ç»†çš„é”®ç å’Œå­—ç¬¦ä¿¡æ¯
```

**ç”¨é€”**:
- æŸ¥çœ‹é”®ç›˜æŒ‰é”®çš„ keycode å’Œ keysym
- è°ƒè¯•é¼ æ ‡äº‹ä»¶
- æŸ¥çœ‹çª—å£ç„¦ç‚¹å˜åŒ–

#### 2. xwininfo - çª—å£ä¿¡æ¯

```bash
# ç‚¹å‡»çª—å£æŸ¥çœ‹ä¿¡æ¯
xwininfo

# è¾“å‡º:
xwininfo: Window id: 0x3200001 "Firefox"

  Absolute upper-left X:  100
  Absolute upper-left Y:  100
  Relative upper-left X:  0
  Relative upper-left Y:  0
  Width: 1920
  Height: 1080
  Depth: 24
  Visual: 0x21
  Visual Class: TrueColor
  Border width: 0
  Class: InputOutput
  Colormap: 0x20 (installed)
  Bit Gravity State: NorthWestGravity
  Window Gravity State: NorthWestGravity
  Backing Store State: NotUseful
  Save Under State: no
  Map State: IsViewable
  Override Redirect State: no
  Corners:  +100+100  -100+100  -100-100  +100-100

# æ˜¾ç¤ºçª—å£æ ‘
xwininfo -root -tree
```

#### 3. xprop - çª—å£å±æ€§

```bash
# æŸ¥çœ‹çª—å£å±æ€§
xprop

# ç‚¹å‡»çª—å£åè¾“å‡º:
_NET_WM_NAME(UTF8_STRING) = "Firefox"
WM_CLASS(STRING) = "Navigator", "Firefox"
_NET_WM_PID(CARDINAL) = 12345
_NET_WM_STATE(ATOM) = _NET_WM_STATE_MAXIMIZED_VERT, _NET_WM_STATE_MAXIMIZED_HORZ

# æŸ¥çœ‹æ ¹çª—å£å±æ€§
xprop -root
```

#### 4. xdpyinfo - Display ä¿¡æ¯

```bash
# æŸ¥çœ‹ Display è¯¦ç»†ä¿¡æ¯
xdpyinfo

# è¾“å‡ºåŒ…æ‹¬:
# - å±å¹•æ•°é‡å’Œåˆ†è¾¨ç‡
# - å¯ç”¨æ‰©å±•
# - Visual ç±»å‹
# - DPI è®¾ç½®

# æŸ¥çœ‹æ‰©å±•
xdpyinfo | grep "number of extensions"
xdpyinfo | grep -A 30 "extensions:"
```

#### 5. xtrace - åè®®è·Ÿè¸ª

```bash
# å®‰è£…
sudo pacman -S xtrace  # Arch
sudo apt install xtrace  # Debian/Ubuntu

# ä½¿ç”¨
xtrace -D :0 firefox

# è¾“å‡ºæ‰€æœ‰ X11 åè®®æ¶ˆæ¯ (ç±»ä¼¼äº strace)
000:<:0000: 32: Request(1): CreateWindow depth=0x18 wid=0x03200001 parent=0x000002b1 ...
000:>:0000: 32: Reply to CreateWindow: ...
```

### Wayland è°ƒè¯•å·¥å…·

#### 1. WAYLAND_DEBUG - åè®®æ—¥å¿—

```bash
# å¯ç”¨ Wayland åè®®è°ƒè¯•
WAYLAND_DEBUG=1 firefox

# è¾“å‡ºç¤ºä¾‹:
[1234567.890] wl_display@1.get_registry(new id wl_registry@2)
[1234567.891]  -> wl_registry@2.global(1, "wl_compositor", 4)
[1234567.891]  -> wl_registry@2.global(2, "wl_shm", 1)
[1234567.892] wl_registry@2.bind(1, "wl_compositor", 4, new id [unknown]@3)
[1234567.893] wl_compositor@3.create_surface(new id wl_surface@4)

# åªæ˜¾ç¤ºå®¢æˆ·ç«¯å‘é€çš„æ¶ˆæ¯
WAYLAND_DEBUG=client firefox

# åªæ˜¾ç¤ºæœåŠ¡å™¨å‘é€çš„æ¶ˆæ¯
WAYLAND_DEBUG=server firefox
```

#### 2. wldbg - Wayland è°ƒè¯•å™¨

```bash
# å®‰è£… (ä»æºç ç¼–è¯‘)
git clone https://github.com/anupamah/wldbg.git
cd wldbg
make

# ä½¿ç”¨
wldbg firefox
```

#### 3. wayland-info - æ˜¾ç¤º Wayland ä¿¡æ¯

```bash
# å®‰è£… (é€šå¸¸åŒ…å«åœ¨ wayland-utils ä¸­)
sudo pacman -S wayland-utils

# æ˜¾ç¤ºæ‰€æœ‰ Wayland å…¨å±€å¯¹è±¡
wayland-info

# è¾“å‡º:
interface: 'wl_compositor', version: 4, name: 1
interface: 'wl_shm', version: 1, name: 2
interface: 'wl_output', version: 3, name: 3
interface: 'wl_seat', version: 7, name: 4
interface: 'xdg_wm_base', version: 2, name: 5
```

#### 4. weston-info - Weston è°ƒè¯•ä¿¡æ¯

```bash
# æ˜¾ç¤º Weston åˆæˆå™¨ä¿¡æ¯
weston-info

# è¾“å‡ºåŒ…æ‹¬:
# - æ”¯æŒçš„åè®®
# - è¾“å‡ºè®¾å¤‡ä¿¡æ¯
# - è¾“å…¥è®¾å¤‡ä¿¡æ¯
```

---

## ğŸ› å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

### é—®é¢˜ 1: Wayland åº”ç”¨ä¸æ˜¾ç¤º

**ç—‡çŠ¶**:
```bash
./my_wayland_app
# ç¨‹åºè¿è¡Œ,ä½†æ²¡æœ‰çª—å£æ˜¾ç¤º
```

**åŸå› **: ç¼ºå°‘ `xdg-shell` åè®®æˆ–æœªæ­£ç¡®é…ç½® `xdg_surface`

**è§£å†³æ–¹æ¡ˆ**:
```c
// æ£€æŸ¥æ˜¯å¦æ­£ç¡®åˆ›å»ºäº† xdg_toplevel
struct xdg_surface* xdg_surface = xdg_wm_base_get_xdg_surface(xdg_wm, surface);
struct xdg_toplevel* toplevel = xdg_surface_get_toplevel(xdg_surface);

// å¿…é¡»æ·»åŠ é…ç½®ç›‘å¬å™¨!
static void xdg_surface_configure(void* data, struct xdg_surface* xdg_surface,
                                  uint32_t serial) {
    xdg_surface_ack_configure(xdg_surface, serial);  // å¿…é¡»ç¡®è®¤!
}

static const struct xdg_surface_listener xdg_surface_listener = {
    .configure = xdg_surface_configure,
};

xdg_surface_add_listener(xdg_surface, &xdg_surface_listener, NULL);

// æœ€åæäº¤
wl_surface_commit(surface);
```

### é—®é¢˜ 2: RGFW åœ¨ Wayland ä¸Šå´©æºƒ

**ç—‡çŠ¶**:
```bash
RGFW_DEBUG=1 ./my_rgfw_app
# Segmentation fault (core dumped)
```

**åŸå› **: RGFW çš„ Wayland æ”¯æŒä»åœ¨å¼€å‘ä¸­,æŸäº›åŠŸèƒ½å¯èƒ½ä¸å®Œæ•´

**è§£å†³æ–¹æ¡ˆ**:
```bash
# æ–¹æ³• 1: å¼ºåˆ¶ä½¿ç”¨ X11 (é€šè¿‡ XWayland)
unset WAYLAND_DISPLAY
export DISPLAY=:0
./my_rgfw_app

# æ–¹æ³• 2: ç¼–è¯‘æ—¶ç¦ç”¨ Wayland
gcc -DRGFW_X11 -o my_app main.c -lX11 -lGL

# æ–¹æ³• 3: å¯ç”¨è°ƒè¯•ä¿¡æ¯æŸ¥çœ‹è¯¦ç»†é”™è¯¯
WAYLAND_DEBUG=1 ./my_rgfw_app 2>&1 | less
```

### é—®é¢˜ 3: X11 åº”ç”¨åœ¨ Wayland ä¸Šé—ªçƒ

**ç—‡çŠ¶**: é€šè¿‡ XWayland è¿è¡Œçš„ X11 åº”ç”¨çª—å£é—ªçƒæˆ–æ’•è£‚

**åŸå› **: XWayland çš„åˆæˆé…ç½®é—®é¢˜

**è§£å†³æ–¹æ¡ˆ**:
```bash
# æ£€æŸ¥ XWayland æ˜¯å¦æ­£ç¡®è¿è¡Œ
ps aux | grep Xwayland

# è¾“å‡ºåº”è¯¥æ˜¾ç¤ºç±»ä¼¼:
# /usr/bin/Xwayland :0 -rootless -terminate -wm ...

# å¦‚æœ XWayland æœªè¿è¡Œ,é‡å¯ Wayland åˆæˆå™¨
# GNOME:
killall gnome-shell
gnome-shell --replace &

# KDE:
killall kwin_wayland
kwin_wayland --replace &
```

### é—®é¢˜ 4: OpenGL ä¸Šä¸‹æ–‡åˆ›å»ºå¤±è´¥

**ç—‡çŠ¶**:
```
Failed to create OpenGL context
```

**X11 è§£å†³æ–¹æ¡ˆ**:
```c
// æ£€æŸ¥ GLX æ‰©å±•
int glx_major, glx_minor;
if (!glXQueryVersion(display, &glx_major, &glx_minor)) {
    fprintf(stderr, "GLX ä¸å¯ç”¨\n");
    return 1;
}

// ä½¿ç”¨æ­£ç¡®çš„ Visual
GLint att[] = {
    GLX_RGBA,
    GLX_DEPTH_SIZE, 24,
    GLX_DOUBLEBUFFER,
    GLX_RED_SIZE, 8,
    GLX_GREEN_SIZE, 8,
    GLX_BLUE_SIZE, 8,
    None
};

XVisualInfo* vi = glXChooseVisual(display, 0, att);
if (vi == NULL) {
    fprintf(stderr, "æ²¡æœ‰åˆé€‚çš„ Visual\n");
    return 1;
}
```

**Wayland è§£å†³æ–¹æ¡ˆ**:
```c
// æ£€æŸ¥ EGL ç‰ˆæœ¬
EGLint major, minor;
if (!eglInitialize(egl_display, &major, &minor)) {
    fprintf(stderr, "EGL åˆå§‹åŒ–å¤±è´¥: %d\n", eglGetError());
    return 1;
}

// ç»‘å®š OpenGL API
eglBindAPI(EGL_OPENGL_API);  // æˆ– EGL_OPENGL_ES_API

// ä½¿ç”¨æ­£ç¡®çš„é…ç½®å±æ€§
EGLint config_attribs[] = {
    EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
    EGL_RED_SIZE, 8,
    EGL_GREEN_SIZE, 8,
    EGL_BLUE_SIZE, 8,
    EGL_ALPHA_SIZE, 8,
    EGL_DEPTH_SIZE, 24,
    EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,  // æˆ– EGL_OPENGL_ES2_BIT
    EGL_NONE
};
```

### é—®é¢˜ 5: çª—å£å¤§å°ä¸æ­£ç¡®

**X11 è§£å†³æ–¹æ¡ˆ**:
```c
// æ£€æŸ¥çª—å£ç®¡ç†å™¨æç¤º
XSizeHints* hints = XAllocSizeHints();
hints->flags = PSize | PMinSize | PMaxSize;
hints->width = hints->min_width = hints->max_width = 800;
hints->height = hints->min_height = hints->max_height = 600;
XSetWMNormalHints(display, win, hints);
XFree(hints);
```

**Wayland è§£å†³æ–¹æ¡ˆ**:
```c
// è®¾ç½®çª—å£å¤§å°é™åˆ¶
xdg_toplevel_set_min_size(toplevel, 400, 300);
xdg_toplevel_set_max_size(toplevel, 1920, 1080);

// ç›‘å¬ configure äº‹ä»¶
static void xdg_toplevel_configure(void* data, struct xdg_toplevel* toplevel,
                                    int32_t width, int32_t height,
                                    struct wl_array* states) {
    if (width > 0 && height > 0) {
        // åˆæˆå™¨å»ºè®®çš„å¤§å°,è°ƒæ•´ EGL window
        wl_egl_window_resize(egl_window, width, height, 0, 0);
    }
}
```

---

## ğŸ”„ ä» X11 è¿ç§»åˆ° Wayland

### è¿ç§»æ£€æŸ¥æ¸…å•

```
â–¡ ç§»é™¤å…¨å±€è¾“å…¥ç›‘å¬ä»£ç  (Wayland ä¸æ”¯æŒ)
â–¡ ä½¿ç”¨ EGL æ›¿ä»£ GLX (OpenGL ä¸Šä¸‹æ–‡)
â–¡ æ·»åŠ  xdg-shell åè®®æ”¯æŒ
â–¡ å¤„ç†å¼‚æ­¥äº‹ä»¶å›è°ƒ
â–¡ ä½¿ç”¨ PipeWire æ›¿ä»£ç›´æ¥æˆªå›¾
â–¡ æµ‹è¯• XWayland å…¼å®¹æ€§
â–¡ æ›´æ–°æ–‡æ¡£å’Œæ„å»ºè„šæœ¬
```

### è¿ç§»ç­–ç•¥ 1: åŒå®ç° (æ¨è)

```c
// åƒ RGFW ä¸€æ ·,åŒæ—¶æ”¯æŒä¸¤è€…

#ifdef RGFW_X11
    // X11 å®ç°
    typedef struct {
        Display* display;
        Window window;
    } Window_X11;

    Window_X11* create_window_x11(int width, int height) {
        // X11 åˆ›å»ºçª—å£ä»£ç ...
    }
#endif

#ifdef RGFW_WAYLAND
    // Wayland å®ç°
    typedef struct {
        struct wl_display* display;
        struct wl_surface* surface;
        struct xdg_toplevel* toplevel;
    } Window_Wayland;

    Window_Wayland* create_window_wayland(int width, int height) {
        // Wayland åˆ›å»ºçª—å£ä»£ç ...
    }
#endif

// ç»Ÿä¸€æ¥å£
typedef struct {
    #ifdef RGFW_X11
        Window_X11* x11;
    #endif
    #ifdef RGFW_WAYLAND
        Window_Wayland* wayland;
    #endif
} Window;

Window* create_window(int width, int height) {
    #if defined(RGFW_WAYLAND) && defined(RGFW_X11)
        // è¿è¡Œæ—¶æ£€æµ‹
        if (getenv("WAYLAND_DISPLAY")) {
            return create_window_wayland(width, height);
        } else {
            return create_window_x11(width, height);
        }
    #elif defined(RGFW_WAYLAND)
        return create_window_wayland(width, height);
    #elif defined(RGFW_X11)
        return create_window_x11(width, height);
    #endif
}
```

### è¿ç§»ç­–ç•¥ 2: ä½¿ç”¨æŠ½è±¡æ¡†æ¶

```c
// ç›´æ¥ä½¿ç”¨ RGFW ç­‰æ¡†æ¶
#define RGFW_IMPLEMENTATION
#include "RGFW.h"

// æ¡†æ¶è‡ªåŠ¨å¤„ç† X11/Wayland åˆ‡æ¢
RGFW_window* win = RGFW_createWindow("My App", 0, 0, 800, 600, 0);

// æ— éœ€å…³å¿ƒåº•å±‚å®ç°!
while (!RGFW_window_shouldClose(win)) {
    while (RGFW_window_checkEvent(win, &event)) {
        // å¤„ç†äº‹ä»¶...
    }
}
```

### è¿ç§»ç­–ç•¥ 3: ä»… XWayland å…¼å®¹

```bash
# ä¸ä¿®æ”¹ä»£ç ,ç›´æ¥åœ¨ Wayland ä¸Šé€šè¿‡ XWayland è¿è¡Œ
# ä¼˜ç‚¹: æ— éœ€ä¿®æ”¹ä»£ç 
# ç¼ºç‚¹: æ€§èƒ½ç•¥ä½äºåŸç”Ÿ Wayland,æŸäº› X11 ç‰¹æ€§ä¸å¯ç”¨

# ç¼–è¯‘ä¸º X11 åº”ç”¨
gcc -o my_app main.c -lX11 -lGL

# åœ¨ Wayland ä¸Šè¿è¡Œ (è‡ªåŠ¨é€šè¿‡ XWayland)
./my_app
```

---

## ğŸ§ª æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### X11 æ€§èƒ½ä¼˜åŒ–

```c
// 1. ä½¿ç”¨å…±äº«å†…å­˜æ‰©å±• (MIT-SHM)
#include <X11/extensions/XShm.h>
#include <sys/ipc.h>
#include <sys/shm.h>

// æ£€æŸ¥æ‰©å±•
if (!XShmQueryExtension(display)) {
    fprintf(stderr, "MIT-SHM ä¸å¯ç”¨\n");
}

// åˆ›å»ºå…±äº«å†…å­˜æ®µ
XShmSegmentInfo shminfo;
XImage* image = XShmCreateImage(display, visual, depth, ZPixmap, NULL,
                                &shminfo, width, height);

shminfo.shmid = shmget(IPC_PRIVATE, image->bytes_per_line * height,
                       IPC_CREAT | 0777);
shminfo.shmaddr = image->data = shmat(shminfo.shmid, 0, 0);
shminfo.readOnly = False;

XShmAttach(display, &shminfo);

// ä½¿ç”¨å…±äº«å†…å­˜ä¼ è¾“å›¾åƒ (æ¯” XPutImage å¿«å¾ˆå¤š!)
XShmPutImage(display, win, gc, image, 0, 0, 0, 0, width, height, False);

// 2. æ‰¹é‡è¯·æ±‚
XSync(display, False);  // åˆ·æ–°è¯·æ±‚ç¼“å†²åŒº
```

### Wayland æ€§èƒ½ä¼˜åŒ–

```c
// 1. ä½¿ç”¨é›¶æ‹·è´ GPU ç¼“å†²åŒº (DMA-BUF)
#include <linux/dma-buf.h>

// åˆ›å»º DMA-BUF (éœ€è¦ GBM)
struct gbm_bo* bo = gbm_bo_create(gbm_device, width, height,
                                  GBM_FORMAT_ARGB8888,
                                  GBM_BO_USE_RENDERING | GBM_BO_USE_SCANOUT);

int fd = gbm_bo_get_fd(bo);

// å¯¼å…¥åˆ° Wayland
struct zwp_linux_buffer_params_v1* params =
    zwp_linux_dmabuf_v1_create_params(dmabuf);

zwp_linux_buffer_params_v1_add(params, fd, 0, offset, stride, modifier_hi, modifier_lo);

struct wl_buffer* buffer = zwp_linux_buffer_params_v1_create_immed(
    params, width, height, format, 0);

// ç›´æ¥ä½¿ç”¨ GPU ç¼“å†²åŒº,æ— éœ€ CPU å¤åˆ¶!
wl_surface_attach(surface, buffer, 0, 0);

// 2. ä½¿ç”¨å¸§å›è°ƒé¿å…è¿‡åº¦æ¸²æŸ“
struct wl_callback* callback = wl_surface_frame(surface);
wl_callback_add_listener(callback, &frame_listener, NULL);

static void frame_done(void* data, struct wl_callback* callback, uint32_t time) {
    // ä¸Šä¸€å¸§å·²æ˜¾ç¤º,å¯ä»¥æ¸²æŸ“ä¸‹ä¸€å¸§
    render_frame();

    // è¯·æ±‚ä¸‹ä¸€å¸§å›è°ƒ
    callback = wl_surface_frame(surface);
    wl_callback_add_listener(callback, &frame_listener, NULL);
    wl_surface_commit(surface);
}
```

---

## ğŸ”¨ å®æˆ˜é¡¹ç›®:è·¨å¹³å°çª—å£æ¡†æ¶

### é¡¹ç›®ç»“æ„

```
my_window_lib/
â”œâ”€â”€ include/
â”‚   â””â”€â”€ window.h           # å…¬å…± API
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ window_common.c    # é€šç”¨ä»£ç 
â”‚   â”œâ”€â”€ window_x11.c       # X11 å®ç°
â”‚   â””â”€â”€ window_wayland.c   # Wayland å®ç°
â”œâ”€â”€ examples/
â”‚   â””â”€â”€ simple_window.c    # ç¤ºä¾‹
â””â”€â”€ Makefile
```

### window.h (å…¬å…± API)

```c
#ifndef WINDOW_H
#define WINDOW_H

typedef struct Window Window;

typedef enum {
    EVENT_QUIT,
    EVENT_KEY_PRESS,
    EVENT_MOUSE_MOVE,
} EventType;

typedef struct {
    EventType type;
    union {
        struct { int key; } key_press;
        struct { int x, y; } mouse_move;
    };
} Event;

// API
Window* window_create(int width, int height, const char* title);
void window_destroy(Window* win);
int window_poll_event(Window* win, Event* event);
void window_swap_buffers(Window* win);

#endif
```

### ç¼–è¯‘è„šæœ¬

```makefile
# Makefile
CC = gcc
CFLAGS = -Wall -Wextra -O2

# è‡ªåŠ¨æ£€æµ‹ Wayland
HAS_WAYLAND := $(shell pkg-config --exists wayland-client && echo 1)
HAS_X11 := $(shell pkg-config --exists x11 && echo 1)

ifeq ($(HAS_WAYLAND), 1)
    CFLAGS += -DSUPPORT_WAYLAND
    LIBS += $(shell pkg-config --libs wayland-client wayland-egl)
endif

ifeq ($(HAS_X11), 1)
    CFLAGS += -DSUPPORT_X11
    LIBS += -lX11 -lGL
endif

all: simple_window

simple_window: examples/simple_window.c src/*.c
	$(CC) $(CFLAGS) -o $@ $^ $(LIBS)

clean:
	rm -f simple_window
```

---

## ğŸ“š æ¨èå­¦ä¹ èµ„æº

### X11 èµ„æº

- [Xlib ç¼–ç¨‹æ‰‹å†Œ](https://tronche.com/gui/x/xlib/)
- [X11 åè®®è§„èŒƒ](https://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html)
- [Arch Wiki - Xorg](https://wiki.archlinux.org/title/Xorg)

### Wayland èµ„æº

- [Wayland å®˜æ–¹æ–‡æ¡£](https://wayland.freedesktop.org/docs/html/)
- [Wayland Book](https://wayland-book.com/) - æœ€ä½³å…¥é—¨æ•™ç¨‹
- [Weston æºç ](https://gitlab.freedesktop.org/wayland/weston) - å‚è€ƒå®ç°

### RGFW ç›¸å…³

- [RGFW GitHub](https://github.com/ColleagueRiley/RGFW)
- [RGFW æ–‡æ¡£](https://colleagueriley.github.io/RGFW/docs/)
- [RGFW ç¤ºä¾‹](https://github.com/ColleagueRiley/RGFW/tree/main/examples)

---

## ğŸ¯ æ€»ç»“

```
è°ƒè¯•å·¥å…·é€ŸæŸ¥:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
X11                      Wayland
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
xev (äº‹ä»¶ç›‘è§†)           WAYLAND_DEBUG=1 (åè®®æ—¥å¿—)
xwininfo (çª—å£ä¿¡æ¯)      wayland-info (å…¨å±€å¯¹è±¡)
xprop (çª—å£å±æ€§)         weston-info (åˆæˆå™¨ä¿¡æ¯)
xdpyinfo (Display ä¿¡æ¯)  -
xtrace (åè®®è·Ÿè¸ª)        wldbg (è°ƒè¯•å™¨)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

è¿ç§»ç­–ç•¥:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ç­–ç•¥                ä¼˜ç‚¹                  ç¼ºç‚¹
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
åŒå®ç°              å…¼å®¹æ€§æœ€å¥½            ä»£ç é‡å¤§
æŠ½è±¡æ¡†æ¶ (RGFW)     ä»£ç ç®€å•              ä¾èµ–å¤–éƒ¨åº“
ä»… XWayland         æ— éœ€ä¿®æ”¹ä»£ç           æ€§èƒ½ç•¥ä½
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

æ€§èƒ½ä¼˜åŒ–:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
X11: ä½¿ç”¨ MIT-SHM å…±äº«å†…å­˜,æ‰¹é‡è¯·æ±‚
Wayland: ä½¿ç”¨ DMA-BUF é›¶æ‹·è´,å¸§å›è°ƒåŒæ­¥
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
```

---

**ä½ ç°åœ¨å·²ç»æŒæ¡äº†**:
- âœ… X11 å’Œ Wayland çš„è°ƒè¯•å·¥å…·
- âœ… å¸¸è§é—®é¢˜çš„è§£å†³æ–¹æ¡ˆ
- âœ… ä» X11 è¿ç§»åˆ° Wayland çš„ç­–ç•¥
- âœ… æ€§èƒ½ä¼˜åŒ–æŠ€å·§
- âœ… å®æˆ˜é¡¹ç›®å¼€å‘ç»éªŒ

**ä¸‹ä¸€æ­¥å»ºè®®**:
1. å°è¯•ä¿®æ”¹ RGFW ç¤ºä¾‹,æ·»åŠ è‡ªå®šä¹‰åŠŸèƒ½
2. ä½¿ç”¨è°ƒè¯•å·¥å…·åˆ†æä½ è‡ªå·±çš„åº”ç”¨
3. ç¼–å†™ä¸€ä¸ªåŒæ—¶æ”¯æŒ X11 å’Œ Wayland çš„å°é¡¹ç›®
4. å‚ä¸ RGFW ç­‰å¼€æºé¡¹ç›®,è´¡çŒ®ä»£ç 
