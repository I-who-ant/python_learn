# Vue vs React - 框架基础对比

## 1. 基本信息

### 历史背景

| 特性 | Vue | React |
|------|-----|-------|
| **创建者** | 尤雨溪 (中国开发者) | Facebook (Meta) |
| **首次发布** | 2014年2月 | 2013年5月 |
| **开源协议** | MIT | MIT |
| **类型** | 渐进式框架 | UI 库 |
| **官网** | https://cn.vuejs.org | https://react.dev |
| **GitHub Stars** | 210k+ | 230k+ |

### 核心理念

#### Vue: 渐进式框架

```

Vue 的理念:
- 可以逐步采用 (从简单到复杂)
- 核心库 + 官方工具链
- 降低学习曲线
- 亲和力强


使用场景:
├─ 在现有页面中嵌入 Vue 组件 ✅
├─ 构建单页应用 (SPA) ✅
├─ 服务端渲染 (SSR) ✅
└─ 静态站点生成 (SSG) ✅

```

#### React: JavaScript 库

```
React 的理念:
- 只关注 UI 层
- 组件化思想
- 函数式编程
- 社区驱动生态

使用场景:
├─ 需要搭配路由、状态管理等库
├─ 更像是 UI 工具箱
├─ 高度灵活,自由度大
└─ 适合大型项目
```

## 2. 核心概念对比

### 2.1 组件定义方式

#### Vue - 单文件组件 (.vue)

```vue
<!-- Counter.vue -->
<template>
  <div class="counter">
    <h1>{{ title }}</h1>
    <p>当前计数: {{ count }}</p>
    <button @click="increment">增加</button>
    <button @click="decrement">减少</button>
  </div>
</template>

<script setup>
import { ref } from 'vue'

// Props
const props = defineProps({
  title: {
    type: String,
    default: '计数器'
  }
})

// State
const count = ref(0)

// Methods
const increment = () => {
  count.value++
}

const decrement = () => {
  count.value--
}
</script>

<style scoped>
.counter {
  padding: 20px;
  border: 1px solid #ccc;
}

button {
  margin: 5px;
  padding: 10px;
}
</style>
```

**特点:**
- ✅ **三部分分离**: 模板、逻辑、样式清晰分开
- ✅ **模板语法**: 类似 HTML,易于理解
- ✅ **样式作用域**: `scoped` 自动隔离样式
- ✅ **直观**: 前端开发者容易上手

#### React - JSX 组件

```jsx
// Counter.jsx
import React, { useState } from 'react'
import './Counter.css'

function Counter({ title = '计数器' }) {
  // State
  const [count, setCount] = useState(0)

  // Methods
  const increment = () => {
    setCount(count + 1)
  }

  const decrement = () => {
    setCount(count - 1)
  }

  return (
    <div className="counter">
      <h1>{title}</h1>
      <p>当前计数: {count}</p>
      <button onClick={increment}>增加</button>
      <button onClick={decrement}>减少</button>
    </div>
  )
}

export default Counter
```

```css
/* Counter.css */
.counter {
  padding: 20px;
  border: 1px solid #ccc;
}

button {
  margin: 5px;
  padding: 10px;
}
```

**特点:**
- ✅ **JSX 语法**: HTML 和 JavaScript 混写
- ✅ **JavaScript 为中心**: 一切都是 JavaScript
- ✅ **灵活性高**: 可以使用完整的 JavaScript 能力
- ⚠️ **学习曲线**: JSX 语法需要适应

### 2.2 数据绑定

#### Vue - 响应式数据

```vue
<script setup>
import { ref, computed } from 'vue'

// 响应式数据
const message = ref('Hello Vue!')
const count = ref(0)

// 计算属性
const doubleCount = computed(() => count.value * 2)

// 修改数据 (自动触发更新)
const updateMessage = () => {
  message.value = 'Hello World!'
  count.value++
}
</script>

<template>
  <div>
    <!-- 双向绑定 -->
    <input v-model="message">
    <p>{{ message }}</p>

    <!-- 单向绑定 -->
    <p>Count: {{ count }}</p>
    <p>Double: {{ doubleCount }}</p>

    <button @click="updateMessage">更新</button>
  </div>
</template>
```

**特点:**
- ⭐ **自动依赖追踪**: 数据变化自动更新视图
- ⭐ **双向绑定**: `v-model` 简化表单处理
- ⭐ **Proxy 响应式**: Vue 3 使用 Proxy 实现

#### React - useState Hook

```jsx
import React, { useState, useMemo } from 'react'

function Example() {
  // State
  const [message, setMessage] = useState('Hello React!')
  const [count, setCount] = useState(0)

  // 计算值
  const doubleCount = useMemo(() => count * 2, [count])

  // 更新数据 (手动调用 setter)
  const updateMessage = () => {
    setMessage('Hello World!')
    setCount(count + 1)
  }

  return (
    <div>
      {/* 受控组件 */}
      <input
        value={message}
        onChange={(e) => setMessage(e.target.value)}
      />
      <p>{message}</p>

      <p>Count: {count}</p>
      <p>Double: {doubleCount}</p>

      <button onClick={updateMessage}>更新</button>
    </div>
  )
}
```

**特点:**
- ⭐ **显式更新**: 通过 `setState` 手动触发更新
- ⭐ **不可变数据**: 需要创建新对象/数组
- ⭐ **函数式思想**: 纯函数、不可变性

### 2.3 条件渲染

#### Vue

```vue
<template>
  <div>
    <!-- v-if / v-else-if / v-else -->
    <p v-if="type === 'A'">Type A</p>
    <p v-else-if="type === 'B'">Type B</p>
    <p v-else>Other</p>

    <!-- v-show (CSS display) -->
    <p v-show="isVisible">显示/隐藏</p>
  </div>
</template>
```

#### React

```jsx
function Example({ type, isVisible }) {
  return (
    <div>
      {/* 三元表达式 */}
      {type === 'A' ? (
        <p>Type A</p>
      ) : type === 'B' ? (
        <p>Type B</p>
      ) : (
        <p>Other</p>
      )}

      {/* && 短路 */}
      {isVisible && <p>显示</p>}

      {/* 样式控制 */}
      <p style={{ display: isVisible ? 'block' : 'none' }}>
        显示/隐藏
      </p>
    </div>
  )
}
```

### 2.4 列表渲染

#### Vue

```vue
<template>
  <ul>
    <li v-for="(item, index) in items" :key="item.id">
      {{ index }}. {{ item.name }}
    </li>
  </ul>
</template>

<script setup>
import { ref } from 'vue'

const items = ref([
  { id: 1, name: 'Item 1' },
  { id: 2, name: 'Item 2' },
  { id: 3, name: 'Item 3' }
])
</script>
```

#### React

```jsx
function ItemList() {
  const items = [
    { id: 1, name: 'Item 1' },
    { id: 2, name: 'Item 2' },
    { id: 3, name: 'Item 3' }
  ]

  return (
    <ul>
      {items.map((item, index) => (
        <li key={item.id}>
          {index}. {item.name}
        </li>
      ))}
    </ul>
  )
}
```

## 3. 生命周期对比

### Vue 3 - 组合式 API

```vue
<script setup>
import { ref, onMounted, onUpdated, onUnmounted } from 'vue'

const data = ref(null)

// 组件挂载后
onMounted(() => {
  console.log('组件已挂载')
  // 获取数据
  fetchData()
})

// 组件更新后
onUpdated(() => {
  console.log('组件已更新')
})

// 组件卸载前
onUnmounted(() => {
  console.log('组件即将卸载')
  // 清理工作
  cleanup()
})

const fetchData = async () => {
  const response = await fetch('/api/data')
  data.value = await response.json()
}

const cleanup = () => {
  // 清理定时器、事件监听等
}
</script>
```

### React - Hooks

```jsx
import React, { useState, useEffect } from 'react'

function MyComponent() {
  const [data, setData] = useState(null)

  // 相当于 componentDidMount + componentDidUpdate
  useEffect(() => {
    console.log('组件已挂载或更新')

    // 获取数据
    fetchData()

    // 返回清理函数 (相当于 componentWillUnmount)
    return () => {
      console.log('组件即将卸载')
      cleanup()
    }
  }, []) // 空数组表示只在挂载时执行

  const fetchData = async () => {
    const response = await fetch('/api/data')
    const result = await response.json()
    setData(result)
  }

  const cleanup = () => {
    // 清理工作
  }

  return <div>{/* 渲染 data */}</div>
}
```

## 4. 组件通信

### 4.1 父子组件通信

#### Vue

```vue
<!-- Parent.vue -->
<template>
  <Child
    :message="parentMessage"
    @update="handleUpdate"
  />
</template>

<script setup>
import { ref } from 'vue'
import Child from './Child.vue'

const parentMessage = ref('来自父组件的消息')

const handleUpdate = (data) => {
  console.log('子组件发送:', data)
}
</script>

<!-- Child.vue -->
<template>
  <div>
    <p>{{ message }}</p>
    <button @click="sendToParent">发送给父组件</button>
  </div>
</template>

<script setup>
import { defineProps, defineEmits } from 'vue'

// 接收 props
const props = defineProps({
  message: String
})

// 定义事件
const emit = defineEmits(['update'])

const sendToParent = () => {
  emit('update', '来自子组件的数据')
}
</script>
```

#### React

```jsx
// Parent.jsx
import React, { useState } from 'react'
import Child from './Child'

function Parent() {
  const [parentMessage] = useState('来自父组件的消息')

  const handleUpdate = (data) => {
    console.log('子组件发送:', data)
  }

  return (
    <Child
      message={parentMessage}
      onUpdate={handleUpdate}
    />
  )
}

// Child.jsx
function Child({ message, onUpdate }) {
  const sendToParent = () => {
    onUpdate('来自子组件的数据')
  }

  return (
    <div>
      <p>{message}</p>
      <button onClick={sendToParent}>发送给父组件</button>
    </div>
  )
}
```

### 4.2 跨组件通信

#### Vue - Provide / Inject

```vue
<!-- Grandparent.vue -->
<script setup>
import { provide, ref } from 'vue'

const sharedData = ref('共享数据')

// 提供数据
provide('sharedData', sharedData)
</script>

<!-- Grandchild.vue -->
<script setup>
import { inject } from 'vue'

// 注入数据
const sharedData = inject('sharedData')
</script>

<template>
  <p>{{ sharedData }}</p>
</template>
```

#### React - Context

```jsx
// Context.jsx
import React, { createContext, useContext, useState } from 'react'

const DataContext = createContext()

// Provider
export function DataProvider({ children }) {
  const [sharedData, setSharedData] = useState('共享数据')

  return (
    <DataContext.Provider value={{ sharedData, setSharedData }}>
      {children}
    </DataContext.Provider>
  )
}

// Consumer Hook
export function useData() {
  return useContext(DataContext)
}

// Grandchild.jsx
import { useData } from './Context'

function Grandchild() {
  const { sharedData } = useData()

  return <p>{sharedData}</p>
}
```

## 5. 学习曲线对比

### Vue - 渐进式,易上手

```
学习路径:

第 1 天: 基础语法
├─ 模板语法 (v-if, v-for, v-bind)
├─ 事件处理 (@click)
└─ 数据绑定 (v-model)
✅ 已经可以写简单应用

第 2-3 天: 组件化
├─ 单文件组件 (.vue)
├─ Props 和 Events
└─ 组合式 API
✅ 可以写中等复杂度应用

第 1 周: 进阶
├─ Vue Router (路由)
├─ Pinia (状态管理)
└─ 组合式函数
✅ 可以写复杂应用

第 2-4 周: 精通
├─ 性能优化
├─ 自定义指令
└─ 插件开发
✅ 专业级别
```

### React - 函数式,需要适应

```
学习路径:

第 1-2 天: 基础语法
├─ JSX 语法 (适应期)
├─ 组件和 Props
└─ State 管理
⚠️ JSX 语法需要时间适应

第 3-5 天: Hooks
├─ useState
├─ useEffect
└─ useContext
⚠️ Hooks 规则需要理解

第 1-2 周: 生态系统
├─ React Router (路由)
├─ Redux/Zustand (状态管理)
└─ 各种库的选择
⚠️ 需要自己搭配工具链

第 3-4 周: 进阶
├─ 自定义 Hooks
├─ 性能优化
└─ 设计模式
✅ 可以写复杂应用

第 1-3 月: 精通
├─ 深入理解 Fiber
├─ 高级模式
└─ 生态系统精通
✅ 专业级别
```

## 6. 核心差异总结

### 语法风格

| 特性 | Vue | React |
|------|-----|-------|
| **模板** | HTML-based 模板 | JSX (JavaScript) |
| **样式** | Scoped CSS | CSS-in-JS / CSS Modules |
| **数据绑定** | 双向绑定 (v-model) | 单向数据流 |
| **响应式** | 自动依赖追踪 | 手动 setState |

### 开发体验

| 特性 | Vue | React |
|------|-----|-------|
| **学习曲线** | 平缓 ⭐⭐ | 陡峭 ⭐⭐⭐⭐ |
| **上手速度** | 快 (几天) | 慢 (1-2周) |
| **文档** | 中文文档完善 | 英文为主 |
| **官方工具** | 完整 (Router, Devtools) | 需要社区 |

### 适用场景

| 场景 | Vue | React |
|------|-----|-------|
| **中小型项目** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| **大型项目** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **快速原型** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| **企业应用** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **团队协作** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

## 7. 选择建议

### 选择 Vue 当:

```
✅ 你是前端新手
✅ 需要快速上手
✅ 团队规模较小
✅ 项目复杂度中等
✅ 喜欢模板语法
✅ 需要中文文档
✅ 想要完整的官方生态
```

### 选择 React 当:

```
✅ 你熟悉 JavaScript
✅ 喜欢函数式编程
✅ 需要丰富的第三方库
✅ 大型企业级项目
✅ 团队有 React 经验
✅ 需要 React Native (移动端)
✅ 追求最新技术
```

## 下一步

继续阅读:
- **02-项目结构对比.md**: 详细对比项目目录结构
- **03-语法特性深度对比.md**: 语法细节对比
- **04-生态系统对比.md**: 工具链、UI库对比

---

**总结: Vue 更容易上手,React 更灵活强大。选择取决于团队情况和项目需求!**
