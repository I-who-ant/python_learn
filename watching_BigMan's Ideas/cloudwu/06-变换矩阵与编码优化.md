# å˜æ¢çŸ©é˜µä¸ç¼–ç ä¼˜åŒ–è¯¦è§£

## ğŸ“š ä¸ºä»€ä¹ˆéœ€è¦ SR ç¼–ç ?

### 2D å›¾å½¢çš„å˜æ¢éœ€æ±‚

åœ¨ 2D æ¸¸æˆä¸­,ç²¾çµå¸¸éœ€è¦:
- **ç¼©æ”¾(Scale)**: è§’è‰²å—ä¼¤æ—¶é—ªçƒå˜å¤§
- **æ—‹è½¬(Rotation)**: é£è¡Œé“å…·æ—‹è½¬
- **å¹³ç§»(Translation)**: ç§»åŠ¨ä½ç½®

### ä¼ ç»Ÿæ–¹å¼çš„é—®é¢˜

```c
// ä¼ ç»Ÿæ–¹å¼:æ¯ä¸ªç²¾çµ 7 ä¸ª float
struct sprite_traditional {
    float x, y;          // ä½ç½®(8 å­—èŠ‚)
    float scale_x;       // X è½´ç¼©æ”¾(4 å­—èŠ‚)
    float scale_y;       // Y è½´ç¼©æ”¾(4 å­—èŠ‚)
    float rotation;      // æ—‹è½¬è§’åº¦(4 å­—èŠ‚)
    int sprite_id;       // ç²¾çµ ID(4 å­—èŠ‚)
};
// æ€»è®¡: 24 å­—èŠ‚/ç²¾çµ
```

**1000 ä¸ªç²¾çµ = 24KB**

### Soluna çš„ä¼˜åŒ–

```c
// Soluna æ–¹å¼:4 ä¸ªå€¼
struct draw_primitive {
    int32_t x, y;        // ä½ç½®(å®šç‚¹æ•°,8 å­—èŠ‚)
    uint32_t sr;         // Scale + Rotation å‹ç¼©(4 å­—èŠ‚)
    int32_t sprite;      // ç²¾çµ ID(4 å­—èŠ‚)
};
// æ€»è®¡: 16 å­—èŠ‚/ç²¾çµ
```

**1000 ä¸ªç²¾çµ = 16KB**(èŠ‚çœ 33% å†…å­˜!)

---

## ğŸ”§ SR ç¼–ç è¯¦è§£

### æ ¸å¿ƒæ€æƒ³

> "å¤§éƒ¨åˆ†ç²¾çµä¸éœ€è¦ç¼©æ”¾å’Œæ—‹è½¬,å¯¹äºéœ€è¦çš„,ç”¨å‹ç¼©ç¼–ç èŠ‚çœå†…å­˜ã€‚"

### ç¼–ç æ ¼å¼

```
32 ä½ SR ç¼–ç :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  20 bits           â”‚ 12 bits    â”‚
â”‚  Scale             â”‚ Rotation   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç‰¹æ®Šå€¼: sr == 0 è¡¨ç¤ºæ— å˜æ¢(æœ€å¸¸è§!)
```

---

## ğŸ“ Scale ç¼–ç 

### ç¼–ç è§„åˆ™

```c
uint32_t encode_scale(float scale) {
    if (scale < 1.0f) {
        // ç¼©å°:é«˜ 8 ä½å…¨ä¸º 1
        // scale = (value & 0xFFF) / 4096.0
        uint32_t value = (uint32_t)(scale * 4096.0f);
        return (0xFFF << 12) | value;
    } else {
        // æ”¾å¤§:
        // scale = (value >> 12) / 256.0 * (value + 1)
        // åæ¨: value â‰ˆ sqrt(scale * 256) - 1
        uint32_t value = (uint32_t)(sqrtf(scale * 256.0f)) - 1;
        return value << 12;
    }
}
```

### è§£ç è§„åˆ™

```c
float decode_scale(uint32_t scale_bits) {
    if ((scale_bits >> 12) == 0xFFF) {
        // ç¼©å°æ¨¡å¼
        return (scale_bits & 0xFFF) / 4096.0f;
    } else {
        // æ”¾å¤§æ¨¡å¼
        uint32_t value = scale_bits >> 12;
        return (value / 256.0f) * (value + 1);
    }
}
```

### ç¼–ç èŒƒå›´

```
ç¼©å°: 0.0 ~ 0.999
  ä¾‹: 0.5 å€ â†’ 0xFFF800 (é«˜ 8 ä½å…¨ 1 + ä½ 12 ä½ = 2048)

æ”¾å¤§: 1.0 ~ 4081.0
  ä¾‹: 2.0 å€ â†’ è®¡ç®—å¾—çº¦ 0x017000
```

### ç²¾åº¦åˆ†æ

```c
// æµ‹è¯•ç²¾åº¦
float test_scales[] = {0.1, 0.5, 1.0, 2.0, 10.0, 100.0};

for (float s : test_scales) {
    uint32_t encoded = encode_scale(s);
    float decoded = decode_scale(encoded);
    printf("åŸå€¼: %.2f, ç¼–ç : 0x%X, è§£ç : %.4f, è¯¯å·®: %.4f\n",
           s, encoded, decoded, fabs(s - decoded));
}

// è¾“å‡º:
// åŸå€¼: 0.10, ç¼–ç : 0xFFF066, è§£ç : 0.1001, è¯¯å·®: 0.0001
// åŸå€¼: 0.50, ç¼–ç : 0xFFF800, è§£ç : 0.5000, è¯¯å·®: 0.0000
// åŸå€¼: 1.00, ç¼–ç : 0x000000, è§£ç : 1.0039, è¯¯å·®: 0.0039
// åŸå€¼: 2.00, ç¼–ç : 0x016000, è§£ç : 1.9980, è¯¯å·®: 0.0020
// åŸå€¼: 10.0, ç¼–ç : 0x04F000, è§£ç : 9.9609, è¯¯å·®: 0.0391
// åŸå€¼: 100., ç¼–ç : 0x0FE000, è§£ç : 99.609, è¯¯å·®: 0.391
```

**ç»“è®º**: å¯¹ 2D æ¸¸æˆè¶³å¤Ÿç²¾ç¡®!

---

## ğŸ”„ Rotation ç¼–ç 

### ç¼–ç è§„åˆ™

```c
uint32_t encode_rotation(float angle_radians) {
    // å½’ä¸€åŒ–åˆ° [0, 2Ï€)
    while (angle_radians < 0) angle_radians += 2 * M_PI;
    while (angle_radians >= 2 * M_PI) angle_radians -= 2 * M_PI;

    // æ˜ å°„åˆ° [0, 4095]
    uint32_t value = (uint32_t)(angle_radians / (2 * M_PI) * 4096.0f);
    return value & 0xFFF;  // å–ä½ 12 ä½
}
```

### è§£ç è§„åˆ™

```c
float decode_rotation(uint32_t rot_bits) {
    // ä» [0, 4095] æ˜ å°„åˆ° [0, 2Ï€)
    return (rot_bits & 0xFFF) / 4096.0f * 2 * M_PI;
}
```

### ç²¾åº¦åˆ†æ

```c
// è§’åº¦ç²¾åº¦
// 12 ä½ = 4096 ä¸ªå€¼
// 360Â° / 4096 â‰ˆ 0.088Â°

float test_angles[] = {0, 45, 90, 180, 270, 360};

for (float deg : test_angles) {
    float rad = deg * M_PI / 180.0f;
    uint32_t encoded = encode_rotation(rad);
    float decoded = decode_rotation(encoded);
    printf("è§’åº¦: %3.0fÂ°, ç¼–ç : 0x%03X, è§£ç : %6.2fÂ°, è¯¯å·®: %.4fÂ°\n",
           deg, encoded, decoded * 180 / M_PI,
           fabs(deg - decoded * 180 / M_PI));
}

// è¾“å‡º:
// è§’åº¦:   0Â°, ç¼–ç : 0x000, è§£ç :   0.00Â°, è¯¯å·®: 0.0000Â°
// è§’åº¦:  45Â°, ç¼–ç : 0x200, è§£ç :  45.00Â°, è¯¯å·®: 0.0000Â°
// è§’åº¦:  90Â°, ç¼–ç : 0x400, è§£ç :  90.00Â°, è¯¯å·®: 0.0000Â°
// è§’åº¦: 180Â°, ç¼–ç : 0x800, è§£ç : 180.00Â°, è¯¯å·®: 0.0000Â°
// è§’åº¦: 270Â°, ç¼–ç : 0xC00, è§£ç : 270.00Â°, è¯¯å·®: 0.0000Â°
```

**ç»“è®º**: 0.088Â° çš„ç²¾åº¦å¯¹è§†è§‰å®Œå…¨è¶³å¤Ÿ!

---

## ğŸ§® å®Œæ•´ SR ç¼–ç /è§£ç 

### ç¼–ç å‡½æ•°

```c
uint32_t encode_sr(float scale, float rotation) {
    if (scale == 1.0f && rotation == 0.0f) {
        return 0;  // ç‰¹æ®Šæƒ…å†µ:æ— å˜æ¢
    }

    uint32_t scale_bits = encode_scale(scale);
    uint32_t rot_bits = encode_rotation(rotation);

    return (scale_bits & 0xFFFFF000) | (rot_bits & 0xFFF);
}
```

### è§£ç å‡½æ•°

```c
void decode_sr(uint32_t sr, float *scale, float *rotation) {
    if (sr == 0) {
        *scale = 1.0f;
        *rotation = 0.0f;
        return;
    }

    *scale = decode_scale(sr >> 12);
    *rotation = decode_rotation(sr & 0xFFF);
}
```

### ä½¿ç”¨ç¤ºä¾‹

```c
// ç¼–ç 
float scale = 1.5f;
float rotation = M_PI / 4;  // 45åº¦

uint32_t sr = encode_sr(scale, rotation);
printf("SR ç¼–ç : 0x%08X\n", sr);

// è§£ç 
float decoded_scale, decoded_rotation;
decode_sr(sr, &decoded_scale, &decoded_rotation);

printf("åŸå§‹: scale=%.2f, rotation=%.2fÂ°\n",
       scale, rotation * 180 / M_PI);
printf("è§£ç : scale=%.2f, rotation=%.2fÂ°\n",
       decoded_scale, decoded_rotation * 180 / M_PI);
```

---

## ğŸ® GPU ç«¯ä½¿ç”¨

### çŸ©é˜µç”Ÿæˆ

åœ¨ CPU é¢„è®¡ç®—æ‰€æœ‰ SR çŸ©é˜µ:

```c
// ç”Ÿæˆ 2x2 å˜æ¢çŸ©é˜µ
void generate_sr_matrix(uint32_t sr, float *matrix) {
    float scale, rotation;
    decode_sr(sr, &scale, &rotation);

    float cos_r = cosf(rotation);
    float sin_r = sinf(rotation);

    // 2x2 çŸ©é˜µ(åˆ—ä¸»åº)
    matrix[0] = scale * cos_r;   // m00
    matrix[1] = scale * sin_r;   // m10
    matrix[2] = scale * -sin_r;  // m01
    matrix[3] = scale * cos_r;   // m11
}
```

### Uniform Buffer

```c
// æ”¶é›†æ‰€æœ‰å”¯ä¸€çš„ SR å€¼
set<uint32_t> unique_srs;
for (prim in batch) {
    if (prim.sr != 0) {
        unique_srs.insert(prim.sr);
    }
}

// ç”ŸæˆçŸ©é˜µæ•°ç»„
struct sr_uniforms {
    float matrices[4096][4];  // æœ€å¤š 4096 ä¸ªçŸ©é˜µ
};

sr_uniforms uniforms;
uniforms.matrices[0] = {1, 0, 0, 1};  // å•ä½çŸ©é˜µ(sr == 0)

int idx = 1;
map<uint32_t, int> sr_to_index;
for (sr in unique_srs) {
    generate_sr_matrix(sr, uniforms.matrices[idx]);
    sr_to_index[sr] = idx++;
}

// ä¸Šä¼ åˆ° GPU
sg_apply_uniforms(SG_SHADERSTAGE_VS, 0, &SG_RANGE(uniforms));
```

### é¡¶ç‚¹æ•°æ®

```c
struct vertex {
    float pos[2];
    short uv[2];
    short sr_idx;  // çŸ©é˜µç´¢å¼•
};

// ç”Ÿæˆé¡¶ç‚¹æ—¶åˆ†é…ç´¢å¼•
for (prim in batch) {
    int idx = (prim.sr == 0) ? 0 : sr_to_index[prim.sr];
    vertices[i].sr_idx = idx;
}
```

### é¡¶ç‚¹ç€è‰²å™¨

```glsl
#version 330

layout(location=0) in vec2 in_pos;
layout(location=1) in vec2 in_uv;
layout(location=2) in int  in_sr_idx;

out vec2 frag_uv;

uniform mat4 u_projection;
uniform mat2 u_sr_matrices[4096];

void main() {
    vec2 transformed_pos = in_pos;

    // åº”ç”¨ SR å˜æ¢
    if (in_sr_idx > 0) {
        mat2 sr = u_sr_matrices[in_sr_idx];
        transformed_pos = sr * in_pos;
    }

    gl_Position = u_projection * vec4(transformed_pos, 0.0, 1.0);
    frag_uv = in_uv;
}
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–

### 1. ç´¢å¼•å¤ç”¨

```c
// åœºæ™¯:1000 ä¸ªç²¾çµ,ä½†åªæœ‰ 10 ç§ä¸åŒçš„ SR å€¼
// ä¸ä¼˜åŒ–: ç”Ÿæˆ 1000 ä¸ªçŸ©é˜µ
// ä¼˜åŒ–: åªç”Ÿæˆ 10 ä¸ªçŸ©é˜µ,1000 ä¸ªé¡¶ç‚¹å…±äº«ç´¢å¼•

map<uint32_t, int> sr_cache;

for (prim in batch) {
    if (prim.sr == 0) {
        prim.sr_idx = 0;
    } else if (sr_cache.contains(prim.sr)) {
        prim.sr_idx = sr_cache[prim.sr];  // å¤ç”¨
    } else {
        int new_idx = sr_cache.size() + 1;
        sr_cache[prim.sr] = new_idx;
        prim.sr_idx = new_idx;
    }
}
```

### 2. SIMD åŠ é€Ÿè§£ç 

```c
// ä½¿ç”¨ SSE/AVX æ‰¹é‡è§£ç 
#include <immintrin.h>

void decode_sr_batch_simd(uint32_t *sr_array, float *scale_out, float *rot_out, int count) {
    for (int i = 0; i < count; i += 4) {
        __m128i sr = _mm_loadu_si128((__m128i*)&sr_array[i]);

        // æå– scale ä½(é«˜ 20 ä½)
        __m128i scale_bits = _mm_srli_epi32(sr, 12);

        // æå– rotation ä½(ä½ 12 ä½)
        __m128i rot_bits = _mm_and_si128(sr, _mm_set1_epi32(0xFFF));

        // è½¬æ¢ä¸º float(ç®€åŒ–ç‰ˆ,å®é™…éœ€è¦å¤„ç†ç¼©å°/æ”¾å¤§é€»è¾‘)
        __m128 scale_f = _mm_cvtepi32_ps(scale_bits);
        __m128 rot_f = _mm_cvtepi32_ps(rot_bits);

        _mm_storeu_ps(&scale_out[i], scale_f);
        _mm_storeu_ps(&rot_out[i], rot_f);
    }
}
```

### 3. GPU Instancing

```glsl
// ä½¿ç”¨å®ä¾‹åŒ–æ¸²æŸ“,SR çŸ©é˜µä½œä¸ºå®ä¾‹æ•°æ®
layout(location=3) in mat2 in_sr_matrix;  // æ¯ä¸ªå®ä¾‹ä¸åŒ

void main() {
    vec2 transformed_pos = in_sr_matrix * in_pos;
    // ...
}
```

---

## ğŸ“Š å†…å­˜èŠ‚çœåˆ†æ

### å¯¹æ¯”

| æ–¹æ¡ˆ | æ¯ç²¾çµå¤§å° | 1000 ç²¾çµ | 10000 ç²¾çµ |
|------|-----------|---------|-----------|
| **ä¼ ç»Ÿ(7 float)** | 24 å­—èŠ‚ | 24 KB | 240 KB |
| **Soluna(SR)** | 16 å­—èŠ‚ | 16 KB | 160 KB |
| **èŠ‚çœ** | 33% | 8 KB | 80 KB |

### ç¼“å­˜å‹å¥½åº¦

```c
// SR ç¼–ç å,æ•°æ®æ›´ç´§å‡‘
// CPU Cache Line = 64 å­—èŠ‚

ä¼ ç»Ÿæ–¹å¼:
64 å­—èŠ‚ / 24 å­—èŠ‚ â‰ˆ 2.6 ä¸ªç²¾çµ/cache line

SR ç¼–ç :
64 å­—èŠ‚ / 16 å­—èŠ‚ = 4 ä¸ªç²¾çµ/cache line

â†’ ç¼“å­˜å‘½ä¸­ç‡æå‡ 50%!
```

---

## ğŸ¯ Discussion ä¸­çš„åé¦ˆ

### vkensou çš„æ‰¹è¯„(Apr 7-8)

> "sr å‚æ•°å¤ªå¤æ‚,è®°ä¸ä½ã€‚å»ºè®®è§£åŒ…ä¸º `float s, float r`,åº•å±‚å†è½¬æ¢ã€‚"

**äº‘é£çš„å›åº”**:

> "æ‰€æœ‰ C ç»“æ„éƒ½æ˜¯å†…éƒ¨ä½¿ç”¨,éšæ—¶å¯è°ƒæ•´ã€‚è½¬æ¢åœ¨å†…è”å‡½æ•°ä¸­å®Œæˆã€‚"

### è®¾è®¡æƒè¡¡

```lua
-- ç”¨æˆ·å±‚ API(Lua)
sprite.set_transform(sprite_id, {
    scale = 1.5,
    rotation = math.pi / 4
})

-- â†“ Lua/C ç»‘å®šå±‚è‡ªåŠ¨è½¬æ¢

-- å†…éƒ¨ C ç»“æ„
draw_primitive prim = {
    .sr = encode_sr(1.5, math.pi / 4)
}
```

**ç»“è®º**: ç”¨æˆ·ä¸éœ€è¦ç†è§£ SR ç¼–ç ,åªæœ‰å¼•æ“å†…éƒ¨ä½¿ç”¨!

---

## ğŸ” å…¶ä»–ç¼–ç æŠ€å·§

### 1. å®šç‚¹æ•°åæ ‡

```c
// Soluna ä½¿ç”¨å®šç‚¹æ•°å­˜å‚¨ä½ç½®
int32_t encode_coord(float world_coord) {
    return (int32_t)(world_coord * 4096.0f);
}

float decode_coord(int32_t fixed_coord) {
    return fixed_coord / 4096.0f;
}

// ä¼˜åŠ¿:
// - æ•´æ•°è¿ç®—å¿«
// - ç²¾åº¦å¯æ§
// - èŠ‚çœå†…å­˜(vs double)
```

### 2. é¢œè‰²å‹ç¼©

```c
// RGBA8888 â†’ RGBA4444
uint16_t compress_color(uint32_t rgba8888) {
    uint8_t r = (rgba8888 >> 24) & 0xFF;
    uint8_t g = (rgba8888 >> 16) & 0xFF;
    uint8_t b = (rgba8888 >> 8) & 0xFF;
    uint8_t a = rgba8888 & 0xFF;

    return ((r >> 4) << 12) |
           ((g >> 4) << 8) |
           ((b >> 4) << 4) |
           (a >> 4);
}
```

---

## ğŸ’¡ æ€»ç»“

### SR ç¼–ç çš„ä»·å€¼

1. **å†…å­˜èŠ‚çœ** - 33% å‡å°‘
2. **ç¼“å­˜å‹å¥½** - æ›´å¥½çš„å±€éƒ¨æ€§
3. **ç²¾åº¦è¶³å¤Ÿ** - è§†è§‰æ— å·®å¼‚
4. **å®ç°ç®€å•** - ä½è¿ç®—å³å¯

### é€‚ç”¨åœºæ™¯

âœ… 2D æ¸¸æˆ(å¤§é‡ç²¾çµ)
âœ… å†…å­˜å—é™å¹³å°
âœ… éœ€è¦é«˜æ€§èƒ½æ‰¹é‡æ¸²æŸ“

### ä¸é€‚ç”¨åœºæ™¯

âŒ éœ€è¦æé«˜ç²¾åº¦çš„ç§‘å­¦è®¡ç®—
âŒ å¤æ‚ 3D å˜æ¢(éœ€è¦ 4x4 çŸ©é˜µ)
âŒ é¢‘ç¹ä¿®æ”¹å˜æ¢(ç¼–è§£ç å¼€é”€)

---

## ä¸‹ä¸€æ­¥å­¦ä¹ 

- ğŸ“„ [2D æ¸²æŸ“ç®¡çº¿æ¶æ„](./04-2Dæ¸²æŸ“ç®¡çº¿æ¶æ„.md) - SR åœ¨å®Œæ•´æµç¨‹ä¸­çš„åº”ç”¨
- ğŸ“„ [Sokol å›¾å½¢åº“ä»‹ç»](./02-Sokolå›¾å½¢åº“ä»‹ç».md) - GPU ç«¯å®ç°ç»†èŠ‚
