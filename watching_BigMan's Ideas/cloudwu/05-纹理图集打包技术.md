# çº¹ç†å›¾é›†æ‰“åŒ…æŠ€æœ¯è¯¦è§£

## ğŸ“š ä»€ä¹ˆæ˜¯çº¹ç†å›¾é›†?

### åŸºæœ¬æ¦‚å¿µ

**çº¹ç†å›¾é›†(Texture Atlas)** = å°†å¤šå¼ å°å›¾ç‰‡æ‰“åŒ…åˆ°ä¸€å¼ å¤§å›¾ç‰‡ä¸­

```
å°å›¾ç‰‡(åˆ†æ•£)                    å›¾é›†(åˆå¹¶)
â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ A  â”‚ â”‚ B  â”‚ â”‚ C  â”‚          â”‚ A  â”‚ B  â”‚ C  â”‚
â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜    â†’     â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”                 â”‚ D  â”‚ E  â”‚    â”‚
â”‚ D  â”‚ â”‚ E  â”‚                 â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜
```

### ä¸ºä»€ä¹ˆéœ€è¦å›¾é›†?

| é—®é¢˜ | ä¸ç”¨å›¾é›† | ä½¿ç”¨å›¾é›† |
|------|---------|---------|
| **çº¹ç†åˆ‡æ¢** | æ¯ä¸ªç²¾çµåˆ‡æ¢ä¸€æ¬¡çº¹ç† | åªç»‘å®šä¸€å¼ å¤§å›¾ |
| **Draw Calls** | 1000 ç²¾çµ = 1000 æ¬¡ | 1000 ç²¾çµ = 1 æ¬¡ |
| **å†…å­˜å ç”¨** | æ¯å¼ å›¾æœ‰é¢å¤–å¼€é”€ | åªæœ‰ä¸€å¼ å›¾çš„å¼€é”€ |
| **åŠ è½½é€Ÿåº¦** | åŠ è½½ 1000 ä¸ªæ–‡ä»¶ | åŠ è½½ 1 ä¸ªæ–‡ä»¶ |

**æ€§èƒ½å·®å¼‚**:
```
åœºæ™¯: 1000 ä¸ªä¸åŒç²¾çµ

ä¸ç”¨å›¾é›†:
  ç»‘å®šçº¹ç† 1: draw(sprite_1)
  ç»‘å®šçº¹ç† 2: draw(sprite_2)
  ...
  ç»‘å®šçº¹ç† 1000: draw(sprite_1000)
  â†’ 1000 æ¬¡ draw call
  â†’ FPS: ~20

ä½¿ç”¨å›¾é›†:
  ç»‘å®šå›¾é›†: draw(sprite_1, sprite_2, ..., sprite_1000)
  â†’ 1 æ¬¡ draw call
  â†’ FPS: ~60
```

---

## ğŸ¯ Soluna çš„è®¾è®¡å“²å­¦

### äº‘é£çš„ç†å¿µ(æ¥è‡ª Discussion)

> "ç°ä»£ PC çš„æ€§èƒ½æ—©å·²è¶…å‡º 2D æ¸¸æˆçš„éœ€æ±‚,ç‰ºç‰²ä¸€äº›æ€§èƒ½æ¥æ¢å–è¿è¡Œæ—¶çš„ä¾¿åˆ©,å¯ä»¥ç®€åŒ–å·¥ä½œæµç¨‹,å°¤å…¶æ˜¯å¯¹ Mod åˆ¶ä½œè€…å‹å¥½ã€‚"

### è¿è¡Œæ—¶æ‰“åŒ… vs ç¦»çº¿æ‰“åŒ…

**ä¼ ç»Ÿæ–¹å¼(ç¦»çº¿æ‰“åŒ…)**:
```
å¼€å‘é˜¶æ®µ:
  1. ç”»å¸ˆå¯¼å‡º PNG å›¾ç‰‡
  2. ä½¿ç”¨ TexturePacker ç­‰å·¥å…·æ‰“åŒ…
  3. ç”Ÿæˆå›¾é›† + å…ƒæ•°æ®(JSON/XML)
  4. ç¨‹åºåŠ è½½å›¾é›†å’Œå…ƒæ•°æ®

ä¿®æ”¹æµç¨‹:
  æ”¹å›¾ â†’ é‡æ–°æ‰“åŒ… â†’ é‡æ–°æµ‹è¯•
  â†‘ ç¹ç!
```

**Soluna æ–¹å¼(è¿è¡Œæ—¶æ‰“åŒ…)**:
```
å¼€å‘é˜¶æ®µ:
  1. ç”»å¸ˆå¯¼å‡º PNG å›¾ç‰‡
  2. ç¨‹åºè¿è¡Œæ—¶è‡ªåŠ¨æ‰“åŒ…
  3. æ— éœ€é¢å¤–å·¥å…·

ä¿®æ”¹æµç¨‹:
  æ”¹å›¾ â†’ ç›´æ¥æµ‹è¯•
  â†‘ ç®€å•!
```

### æƒè¡¡åˆ†æ

| ç‰¹æ€§ | ç¦»çº¿æ‰“åŒ… | è¿è¡Œæ—¶æ‰“åŒ… |
|------|---------|-----------|
| **æ€§èƒ½** | æœ€ä¼˜(é¢„å¤„ç†) | ç•¥æ…¢(é¦–æ¬¡) |
| **å·¥ä½œæµ** | å¤æ‚ | ç®€å• |
| **Mod æ”¯æŒ** | å›°éš¾ | å®¹æ˜“ |
| **è°ƒè¯•** | éº»çƒ¦ | æ–¹ä¾¿ |
| **å¯åŠ¨é€Ÿåº¦** | å¿« | é¦–æ¬¡æ…¢,åç»­ç¼“å­˜ |

---

## ğŸ—ï¸ å›¾é›†æ‰“åŒ…ç®—æ³•

### 1. çŸ©å½¢è£…ç®±é—®é¢˜(Bin Packing)

**ç›®æ ‡**: å°† N ä¸ªçŸ©å½¢æ”¾å…¥ä¸€ä¸ªå¤§çŸ©å½¢,ä½¿é¢ç§¯åˆ©ç”¨ç‡æœ€é«˜

```
å¾…æ‰“åŒ…:
â”Œâ”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”
â”‚A â”‚ â”‚ B  â”‚ â”‚Câ”‚
â””â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”˜

æ‰“åŒ…ç»“æœ(Shelf ç®—æ³•):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚A â”‚ B    â”‚ â† Shelf 1
â”œâ”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
â”‚C â”‚      â”‚ â† Shelf 2
â””â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
```

### 2. å¸¸ç”¨ç®—æ³•å¯¹æ¯”

#### (1) Shelf Algorithm(è´§æ¶ç®—æ³•)

```c
// ä¼ªä»£ç 
struct shelf {
    int y;          // è´§æ¶ Y åæ ‡
    int height;     // è´§æ¶é«˜åº¦
    int x_offset;   // å½“å‰ X åç§»
};

void pack_shelf(image_list) {
    sort_by_height(image_list);  // æŒ‰é«˜åº¦æ’åº

    shelf current_shelf = {0, 0, 0};

    for (img in image_list) {
        if (current_shelf.x_offset + img.width > atlas_width) {
            // æ¢æ–°è´§æ¶
            current_shelf.y += current_shelf.height;
            current_shelf.height = img.height;
            current_shelf.x_offset = 0;
        }

        // æ”¾ç½®å›¾ç‰‡
        place_image(img, current_shelf.x_offset, current_shelf.y);
        current_shelf.x_offset += img.width;
        current_shelf.height = max(current_shelf.height, img.height);
    }
}
```

**ä¼˜ç‚¹**: ç®€å•,å¿«é€Ÿ
**ç¼ºç‚¹**: ç©ºé—´æµªè´¹è¾ƒå¤š

#### (2) Guillotine Algorithm(æ–­å¤´å°ç®—æ³•)

```c
// é€’å½’åˆ†å‰²ç©ºé—´
struct free_rect {
    int x, y, width, height;
};

void pack_guillotine(image_list, free_rects) {
    for (img in image_list) {
        // æ‰¾åˆ°æœ€åˆé€‚çš„ç©ºé—²åŒºåŸŸ
        rect = find_best_fit(free_rects, img);

        // æ”¾ç½®å›¾ç‰‡
        place_image(img, rect.x, rect.y);

        // åˆ†å‰²å‰©ä½™ç©ºé—´
        if (rect.width > img.width) {
            add_free_rect(rect.x + img.width, rect.y,
                         rect.width - img.width, img.height);
        }
        if (rect.height > img.height) {
            add_free_rect(rect.x, rect.y + img.height,
                         rect.width, rect.height - img.height);
        }
    }
}
```

**ä¼˜ç‚¹**: ç©ºé—´åˆ©ç”¨ç‡é«˜
**ç¼ºç‚¹**: å¤æ‚,æ€§èƒ½è¾ƒæ…¢

#### (3) MaxRects Algorithm(æœ€å¤§çŸ©å½¢ç®—æ³•)

TexturePacker ä½¿ç”¨çš„ç®—æ³•,æ•ˆæœæœ€å¥½ä½†æœ€å¤æ‚ã€‚

### Soluna çš„é€‰æ‹©

**ç®€åŒ–çš„ Shelf ç®—æ³•**:
- å¿«é€Ÿ(è¿è¡Œæ—¶å¯æ¥å—)
- å®ç°ç®€å•
- å¯¹ 2D æ¸¸æˆè¶³å¤Ÿå¥½(åˆ©ç”¨ç‡ ~70%)

---

## ğŸ”§ Soluna è¿è¡Œæ—¶æ‰“åŒ…å®ç°

### 1. æ•°æ®ç»“æ„

```c
// å›¾é›†ç»“æ„
struct texture_atlas {
    int width;           // å›¾é›†å®½åº¦(é€šå¸¸ 2048)
    int height;          // å›¾é›†é«˜åº¦(é€šå¸¸ 2048)
    uint8_t *pixels;     // RGBA åƒç´ æ•°æ®
    bool dirty;          // æ˜¯å¦éœ€è¦ä¸Šä¼ åˆ° GPU

    // ç²¾çµç´¢å¼•
    struct sprite_region {
        int sprite_id;   // ç²¾çµ ID
        int x, y;        // å›¾é›†ä¸­çš„ä½ç½®
        int w, h;        // åŸå§‹å°ºå¯¸
        float u0, v0;    // UV åæ ‡(å·¦ä¸Š)
        float u1, v1;    // UV åæ ‡(å³ä¸‹)
    } *regions;
    int region_count;

    // æ‰“åŒ…çŠ¶æ€
    int current_y;       // å½“å‰è´§æ¶ Y
    int current_height;  // å½“å‰è´§æ¶é«˜åº¦
    int current_x;       // å½“å‰ X åç§»
};
```

### 2. æ‰“åŒ…æµç¨‹

```c
// æ­¥éª¤ 1: åˆå§‹åŒ–å›¾é›†
texture_atlas* atlas_create(int width, int height) {
    texture_atlas *atlas = malloc(sizeof(*atlas));
    atlas->width = width;
    atlas->height = height;
    atlas->pixels = calloc(width * height, 4);  // RGBA
    atlas->dirty = true;
    atlas->region_count = 0;
    atlas->current_y = 0;
    atlas->current_height = 0;
    atlas->current_x = 0;
    return atlas;
}

// æ­¥éª¤ 2: æ·»åŠ ç²¾çµ
bool atlas_add_sprite(texture_atlas *atlas, int sprite_id, image_t *img) {
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    if (atlas_has_sprite(atlas, sprite_id)) {
        return true;
    }

    // æ£€æŸ¥å½“å‰è¡Œæ˜¯å¦æ”¾å¾—ä¸‹
    if (atlas->current_x + img->width > atlas->width) {
        // æ¢è¡Œ
        atlas->current_y += atlas->current_height;
        atlas->current_x = 0;
        atlas->current_height = 0;
    }

    // æ£€æŸ¥æ˜¯å¦è¶…å‡ºå›¾é›†é«˜åº¦
    if (atlas->current_y + img->height > atlas->height) {
        return false;  // å›¾é›†å·²æ»¡
    }

    // å¤åˆ¶åƒç´ åˆ°å›¾é›†
    int dest_x = atlas->current_x;
    int dest_y = atlas->current_y;

    for (int y = 0; y < img->height; y++) {
        for (int x = 0; x < img->width; x++) {
            int src_idx = (y * img->width + x) * 4;
            int dst_idx = ((dest_y + y) * atlas->width + (dest_x + x)) * 4;

            atlas->pixels[dst_idx + 0] = img->pixels[src_idx + 0];  // R
            atlas->pixels[dst_idx + 1] = img->pixels[src_idx + 1];  // G
            atlas->pixels[dst_idx + 2] = img->pixels[src_idx + 2];  // B
            atlas->pixels[dst_idx + 3] = img->pixels[src_idx + 3];  // A
        }
    }

    // è®¡ç®— UV åæ ‡
    float u0 = (float)dest_x / atlas->width;
    float v0 = (float)dest_y / atlas->height;
    float u1 = (float)(dest_x + img->width) / atlas->width;
    float v1 = (float)(dest_y + img->height) / atlas->height;

    // è®°å½•åŒºåŸŸ
    atlas->regions[atlas->region_count++] = (struct sprite_region){
        .sprite_id = sprite_id,
        .x = dest_x,
        .y = dest_y,
        .w = img->width,
        .h = img->height,
        .u0 = u0,
        .v0 = v0,
        .u1 = u1,
        .v1 = v1
    };

    // æ›´æ–°æ‰“åŒ…çŠ¶æ€
    atlas->current_x += img->width;
    atlas->current_height = max(atlas->current_height, img->height);
    atlas->dirty = true;

    return true;
}

// æ­¥éª¤ 3: ä¸Šä¼ åˆ° GPU
void atlas_upload(texture_atlas *atlas, sg_image *gpu_texture) {
    if (!atlas->dirty) return;

    sg_update_image(*gpu_texture, &(sg_image_data){
        .subimage[0][0] = {
            .ptr = atlas->pixels,
            .size = atlas->width * atlas->height * 4
        }
    });

    atlas->dirty = false;
}

// æ­¥éª¤ 4: æŸ¥è¯¢ç²¾çµä½ç½®
sprite_region* atlas_get_region(texture_atlas *atlas, int sprite_id) {
    for (int i = 0; i < atlas->region_count; i++) {
        if (atlas->regions[i].sprite_id == sprite_id) {
            return &atlas->regions[i];
        }
    }
    return NULL;
}
```

### 3. æ¸²æŸ“æ—¶ä½¿ç”¨

```c
// æ¸²æŸ“å¾ªç¯
void render_frame(draw_batch *batch, texture_atlas *atlas) {
    // æ”¶é›†éœ€è¦çš„ç²¾çµ
    for (int i = 0; i < batch->n; i++) {
        int sprite_id = batch->stream[i].sprite;

        if (!atlas_has_sprite(atlas, sprite_id)) {
            // åŠ è½½å›¾ç‰‡
            image_t *img = load_png(sprite_id);

            // æ·»åŠ åˆ°å›¾é›†
            if (!atlas_add_sprite(atlas, sprite_id, img)) {
                // å›¾é›†å·²æ»¡,åˆ›å»ºæ–°å›¾é›†
                atlas = atlas_create(2048, 2048);
                atlas_add_sprite(atlas, sprite_id, img);
            }

            free_image(img);
        }
    }

    // ä¸Šä¼ å›¾é›†(ä»…å½“æœ‰æ›´æ–°æ—¶)
    atlas_upload(atlas, &gpu_atlas_texture);

    // ç”Ÿæˆé¡¶ç‚¹æ•°æ®
    for (int i = 0; i < batch->n; i++) {
        sprite_region *region = atlas_get_region(atlas, batch->stream[i].sprite);

        // ä½¿ç”¨ region->u0, v0, u1, v1 ç”Ÿæˆé¡¶ç‚¹
        vertices[i*4 + 0].uv = {region->u0, region->v0};
        vertices[i*4 + 1].uv = {region->u1, region->v0};
        vertices[i*4 + 2].uv = {region->u1, region->v1};
        vertices[i*4 + 3].uv = {region->u0, region->v1};
    }
}
```

---

## ğŸš€ ä¼˜åŒ–æŠ€å·§

### 1. é¢„æ’åº

```c
// æŒ‰é«˜åº¦é™åºæ’åº,å‡å°‘æµªè´¹
void sort_images_by_height(image_list) {
    qsort(image_list, count, sizeof(image_t), [](a, b) {
        return b->height - a->height;
    });
}
```

### 2. è¾¹è·(Padding)

```c
// é˜²æ­¢çº¹ç†é‡‡æ ·æ—¶"æ¸—è‰²"
#define ATLAS_PADDING 2

atlas->current_x += img->width + ATLAS_PADDING;
```

### 3. ç¼“å­˜

```c
// ç¼“å­˜å·²æ‰“åŒ…çš„å›¾é›†
// ä¸‹æ¬¡å¯åŠ¨ç›´æ¥åŠ è½½,æ— éœ€é‡æ–°æ‰“åŒ…

struct atlas_cache {
    uint64_t hash;      // æ‰€æœ‰ç²¾çµ ID çš„å“ˆå¸Œ
    char *cache_file;   // "atlas_cache.bin"
};

// ä¿å­˜ç¼“å­˜
void atlas_save_cache(texture_atlas *atlas, const char *path) {
    FILE *f = fopen(path, "wb");
    fwrite(&atlas->width, sizeof(int), 1, f);
    fwrite(&atlas->height, sizeof(int), 1, f);
    fwrite(&atlas->region_count, sizeof(int), 1, f);
    fwrite(atlas->regions, sizeof(sprite_region), atlas->region_count, f);
    fwrite(atlas->pixels, atlas->width * atlas->height * 4, 1, f);
    fclose(f);
}

// åŠ è½½ç¼“å­˜
texture_atlas* atlas_load_cache(const char *path) {
    FILE *f = fopen(path, "rb");
    if (!f) return NULL;

    texture_atlas *atlas = malloc(sizeof(*atlas));
    fread(&atlas->width, sizeof(int), 1, f);
    fread(&atlas->height, sizeof(int), 1, f);
    fread(&atlas->region_count, sizeof(int), 1, f);

    atlas->regions = malloc(sizeof(sprite_region) * atlas->region_count);
    fread(atlas->regions, sizeof(sprite_region), atlas->region_count, f);

    atlas->pixels = malloc(atlas->width * atlas->height * 4);
    fread(atlas->pixels, atlas->width * atlas->height * 4, 1, f);

    fclose(f);
    return atlas;
}
```

### 4. å‹ç¼©çº¹ç†

```c
// è¿è¡Œæ—¶å‹ç¼©å›¾é›†åˆ° DXT/ETC/ASTC
void atlas_compress(texture_atlas *atlas) {
    // ä½¿ç”¨ stb_dxt ç­‰åº“å‹ç¼©
    uint8_t *compressed = compress_dxt5(atlas->pixels, atlas->width, atlas->height);

    // ä¸Šä¼ å‹ç¼©çº¹ç†
    sg_update_image(gpu_texture, &(sg_image_data){
        .subimage[0][0] = {
            .ptr = compressed,
            .size = compressed_size
        }
    });
}
```

---

## ğŸ“Š æ€§èƒ½åˆ†æ

### æ‰“åŒ…æ—¶é—´

```c
// æµ‹è¯•:1000 å¼  64x64 å›¾ç‰‡

// ç¦»çº¿æ‰“åŒ…(TexturePacker)
æ—¶é—´: ~2 ç§’

// è¿è¡Œæ—¶æ‰“åŒ…(Soluna)
é¦–æ¬¡: ~100ms
ç¼“å­˜åŠ è½½: ~10ms
```

### å†…å­˜å ç”¨

```c
// 2048x2048 RGBA å›¾é›†
æœªå‹ç¼©: 16MB
DXT5 å‹ç¼©: 2MB
```

### ç©ºé—´åˆ©ç”¨ç‡

```
Shelf ç®—æ³•: ~70%
MaxRects ç®—æ³•: ~90%

ç»“è®º: Soluna ç‰ºç‰² 20% ç©ºé—´,æ¢å–ç®€å•å®ç°
```

---

## ğŸ¯ æ€»ç»“

### Soluna è¿è¡Œæ—¶æ‰“åŒ…çš„ä¼˜åŠ¿

âœ… **å·¥ä½œæµç®€åŒ–** - ç”»å¸ˆç›´æ¥æ”¾å›¾,æ— éœ€æ‰“åŒ…
âœ… **Mod å‹å¥½** - ç©å®¶ç›´æ¥æ›¿æ¢ PNG
âœ… **è°ƒè¯•æ–¹ä¾¿** - æ”¹å›¾ç«‹å³ç”Ÿæ•ˆ
âœ… **é¦–æ¬¡æ…¢,åç»­å¿«** - ç¼“å­˜æœºåˆ¶

### é€‚åˆåœºæ™¯

âœ… ç‹¬ç«‹æ¸¸æˆå¼€å‘
âœ… éœ€è¦ Mod æ”¯æŒ
âœ… å¿«é€ŸåŸå‹è¿­ä»£
âœ… 2D æ¸¸æˆ(å›¾ç‰‡ä¸å¤š)

### ä¸é€‚åˆåœºæ™¯

âŒ ç§»åŠ¨å¹³å°(å†…å­˜æ•æ„Ÿ)
âŒ æ•°ä¸‡å¼ å›¾ç‰‡çš„å¤§å‹æ¸¸æˆ
âŒ å¯¹å¯åŠ¨é€Ÿåº¦æå…¶æ•æ„Ÿ

---

## ä¸‹ä¸€æ­¥å­¦ä¹ 

- ğŸ“„ [å˜æ¢çŸ©é˜µä¸ç¼–ç ä¼˜åŒ–](./06-å˜æ¢çŸ©é˜µä¸ç¼–ç ä¼˜åŒ–.md) - SR ç¼–ç è¯¦è§£
- ğŸ“„ [2D æ¸²æŸ“ç®¡çº¿æ¶æ„](./04-2Dæ¸²æŸ“ç®¡çº¿æ¶æ„.md) - å®Œæ•´æ¸²æŸ“æµç¨‹
