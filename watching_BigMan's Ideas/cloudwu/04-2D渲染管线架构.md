# 2D æ¸²æŸ“ç®¡çº¿æ¶æ„è¯¦è§£

## ğŸ“š æ ¸å¿ƒè®¾è®¡æ€æƒ³

### äº‘é£çš„è®¾è®¡å“²å­¦(æ¥è‡ª Discussion #1)

> "å¤§éƒ¨åˆ† 2D æ¸¸æˆçš„éœ€æ±‚:æŠŠçŸ©å½¢æ¸²æŸ“åˆ°ç”»å¸ƒä¸Š,ç”»å¸ƒæ•´ä½“ç¼©æ”¾,å…ƒç´ å¤§éƒ¨åˆ†åªæ˜¯æ‘†æ”¾ä½ç½®,ä¸éœ€è¦æ—‹è½¬å’Œç¼©æ”¾ã€‚"

> "ç°ä»£ PC çš„æ€§èƒ½æ—©å·²è¶…å‡º 2D æ¸¸æˆçš„éœ€æ±‚,ç‰ºç‰²ä¸€äº›æ€§èƒ½æ¥æ¢å–è¿è¡Œæ—¶çš„ä¾¿åˆ©,å¯ä»¥ç®€åŒ–å·¥ä½œæµç¨‹,å°¤å…¶æ˜¯å¯¹ Mod åˆ¶ä½œè€…å‹å¥½ã€‚"

### è®¾è®¡ç›®æ ‡

1. **æç®€æ•°æ®ç»“æ„** - ä¸€ä¸ª `draw_primitive` æè¿°æ‰€æœ‰å…ƒç´ 
2. **è¿è¡Œæ—¶æ‰“åŒ…** - è‡ªåŠ¨ç®¡ç†çº¹ç†å›¾é›†,æ— éœ€ç¦»çº¿å·¥å…·
3. **æ‰¹é‡æ¸²æŸ“** - å‡å°‘ draw call,æé«˜æ€§èƒ½
4. **å¤šçº¿ç¨‹å‹å¥½** - ä¸šåŠ¡çº¿ç¨‹ç”Ÿæˆæ‰¹æ¬¡,æ¸²æŸ“çº¿ç¨‹æ¶ˆè´¹

---

## ğŸ—ï¸ æ ¸å¿ƒæ•°æ®ç»“æ„

### 1. draw_primitive - æ¸²æŸ“å›¾å…ƒ

```c
struct draw_primitive {
    int32_t x;           // X åæ ‡(å®šç‚¹æ•°)
    int32_t y;           // Y åæ ‡(å®šç‚¹æ•°)
    uint32_t sr;         // Scale + Rotation(å‹ç¼©ç¼–ç )
    int32_t sprite;      // ç²¾çµ ID æˆ–æè´¨ç´¢å¼•
};
```

**è®¾è®¡è¦ç‚¹**:

#### (1) å®šç‚¹æ•°åæ ‡

```c
// ä¸ºä»€ä¹ˆç”¨ int32 è€Œä¸æ˜¯ float?
// - èŠ‚çœå†…å­˜(32 ä½ vs 32 ä½,ä½†æ•´æ•°è®¡ç®—æ›´å¿«)
// - ç²¾åº¦å¯æ§(å›ºå®šå°æ•°ç‚¹ä½æ•°)
// - CPU ç¼“å­˜å‹å¥½

// ç¼–ç ç¤ºä¾‹(å‡è®¾å®šç‚¹ä½æ•°ä¸º 12)
float world_x = 100.5f;
int32_t fixed_x = (int32_t)(world_x * 4096);  // 4096 = 2^12

// è§£ç 
float decoded_x = fixed_x / 4096.0f;
```

#### (2) SR ç¼–ç  - Scale + Rotation å‹ç¼©

```c
// 32 ä½ç¼–ç :
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ 20 bits    â”‚ 12 bits    â”‚
// â”‚ Scale      â”‚ Rotation   â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

uint32_t sr = (scale << 12) | rotation;

// ç‰¹æ®Šå€¼: sr == 0 è¡¨ç¤ºé»˜è®¤(æ— å˜æ¢)
// - å¤§éƒ¨åˆ†ç²¾çµä¸éœ€è¦ç¼©æ”¾/æ—‹è½¬
// - ä¸º 0 æ—¶ GPU è·³è¿‡çŸ©é˜µè®¡ç®—
```

**Scale ç¼–ç è§„åˆ™**:

```c
// é«˜ 8 ä½å…¨ä¸º 1:ç¼©å°
// ä¾‹: 0xFFF800 >> 12 = 0xFFF
// scale = (value & 0xFFF) / 4096.0
// èŒƒå›´: 0 ~ 0.999

// å¦åˆ™:æ”¾å¤§
// scale = (value >> 12) / 256.0 * (value + 1)
// èŒƒå›´: 1.0 ~ 4081x
```

**Rotation ç¼–ç **:

```c
// 12 ä½,è¡¨ç¤ºåœ†å‘¨è§’åº¦
// rotation_angle = (value / 4096.0) * 2Ï€
// ç²¾åº¦: 360Â° / 4096 â‰ˆ 0.088Â°
```

#### (3) Sprite ç¼–ç 

```c
// sprite > 0: ç²¾çµ ID
// - æŒ‡å‘çº¹ç†å›¾é›†ä¸­çš„åŒºåŸŸ
// - ID å¯¹åº”å›¾é›†ä¸­çš„ç´¢å¼•

// sprite < 0: è‡ªå®šä¹‰æè´¨
// - material_id = -sprite
// - åç»­è·Ÿéš 128 ä½å‚æ•°å—
//   ä¾‹: æ–‡å­—æ¸²æŸ“(é¢œè‰² + Unicode ç ç‚¹)
```

---

### 2. draw_batch - æ¸²æŸ“æ‰¹æ¬¡

```c
struct draw_batch {
    int id;                        // æ‰¹æ¬¡ ID
    int n;                         // å›¾å…ƒæ•°é‡
    struct draw_primitive *stream; // å›¾å…ƒæ•°ç»„
};
```

**æ‰¹æ¬¡ API**:

```c
// åˆ›å»ºæ‰¹æ¬¡(é¢„åˆ†é…ç©ºé—´)
batch_t* batch = batch_new(1024);

// æ·»åŠ å›¾å…ƒ
for (int i = 0; i < sprite_count; i++) {
    batch->stream[i] = (draw_primitive){
        .x = sprites[i].x,
        .y = sprites[i].y,
        .sr = 0,  // æ— å˜æ¢
        .sprite = sprites[i].id
    };
}
batch->n = sprite_count;

// æäº¤åˆ°æ¸²æŸ“çº¿ç¨‹
batch_grab(batch);

// æ¸²æŸ“çº¿ç¨‹å¤„ç†å®Œæ¯•å
batch_release(batch);

// æ£€æŸ¥æ‰¹æ¬¡æ˜¯å¦ç©ºé—²
if (!batch_busy(batch)) {
    // å¯ä»¥é‡ç”¨
}

// é”€æ¯æ‰¹æ¬¡
batch_delete(batch);
```

---

## ğŸ¨ æ¸²æŸ“æµç¨‹

### å®Œæ•´æ¸²æŸ“ç®¡çº¿

```
ä¸šåŠ¡çº¿ç¨‹ 1           ä¸šåŠ¡çº¿ç¨‹ 2           ä¸šåŠ¡çº¿ç¨‹ 3
    â†“                   â†“                   â†“
åˆ›å»º batch_1        åˆ›å»º batch_2        åˆ›å»º batch_3
    â†“                   â†“                   â†“
batch_grab()        batch_grab()        batch_grab()
    â†“â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†“
                    æ¶ˆæ¯é˜Ÿåˆ—
                        â†“
                   æ¸²æŸ“çº¿ç¨‹
                        â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  1. æ”¶é›†æ‰€æœ‰æ‰¹æ¬¡                      â”‚
    â”‚  2. è¿è¡Œæ—¶çº¹ç†å›¾é›†æ‰“åŒ…                â”‚
    â”‚  3. è½¬æ¢ä¸º GPU æ•°æ®                   â”‚
    â”‚  4. æäº¤åˆ° Sokol                      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
                      GPU
```

### é€æ­¥è¯¦è§£

#### æ­¥éª¤ 1: æ”¶é›†æ‰¹æ¬¡

```c
// æ¸²æŸ“çº¿ç¨‹æ¯å¸§æ‰§è¡Œ
void render_frame() {
    batch_list_t batches = collect_all_batches();

    // batches åŒ…å«æ‰€æœ‰çº¿ç¨‹æäº¤çš„æ‰¹æ¬¡
    // ä¾‹: [batch_1, batch_2, batch_3, ...]
}
```

#### æ­¥éª¤ 2: çº¹ç†å›¾é›†æ‰“åŒ…

```c
// éå†æ‰€æœ‰ sprite ID,æŸ¥æ‰¾å¯¹åº”å›¾ç‰‡
for (each sprite_id in batches) {
    if (!atlas.contains(sprite_id)) {
        // åŠ è½½å›¾ç‰‡
        image_t* img = load_image(sprite_id);

        // åŠ¨æ€æ’å…¥å›¾é›†
        atlas_pack(atlas, sprite_id, img);
    }
}

// å¦‚æœå›¾é›†æœ‰æ›´æ–°,é‡æ–°ä¸Šä¼ åˆ° GPU
if (atlas.dirty) {
    sg_update_image(atlas_texture, atlas.pixels);
    atlas.dirty = false;
}
```

#### æ­¥éª¤ 3: ç”Ÿæˆ GPU æ•°æ®

```c
// é¡¶ç‚¹æ ¼å¼
struct vertex {
    float pos[2];     // å±å¹•åæ ‡
    int16_t uv[2];    // çº¹ç†åæ ‡(å½’ä¸€åŒ–)
    int16_t sr_idx;   // SR çŸ©é˜µç´¢å¼•
};

// ä¸ºæ¯ä¸ªå›¾å…ƒç”Ÿæˆ 4 ä¸ªé¡¶ç‚¹(çŸ©å½¢)
vertex_t vertices[batch->n * 4];
uint16_t indices[batch->n * 6];

for (int i = 0; i < batch->n; i++) {
    draw_primitive* prim = &batch->stream[i];

    // ä»å›¾é›†æŸ¥è¯¢ UV åæ ‡
    atlas_region_t region = atlas_get(prim->sprite);

    // ç”ŸæˆçŸ©å½¢é¡¶ç‚¹
    vertices[i*4 + 0] = {prim->x, prim->y, region.u0, region.v0, prim->sr};
    vertices[i*4 + 1] = {prim->x + w, prim->y, region.u1, region.v0, prim->sr};
    vertices[i*4 + 2] = {prim->x + w, prim->y + h, region.u1, region.v1, prim->sr};
    vertices[i*4 + 3] = {prim->x, prim->y + h, region.u0, region.v1, prim->sr};

    // ç”Ÿæˆç´¢å¼•(ä¸¤ä¸ªä¸‰è§’å½¢)
    indices[i*6 + 0] = i*4 + 0;
    indices[i*6 + 1] = i*4 + 1;
    indices[i*6 + 2] = i*4 + 2;
    indices[i*6 + 3] = i*4 + 0;
    indices[i*6 + 4] = i*4 + 2;
    indices[i*6 + 5] = i*4 + 3;
}
```

#### æ­¥éª¤ 4: SR çŸ©é˜µç”Ÿæˆ

```c
// Const Buffer å­˜å‚¨æ‰€æœ‰å˜æ¢çŸ©é˜µ
struct sr_matrices {
    float matrices[MAX_SR][4];  // 2x2 çŸ©é˜µ,å­˜å‚¨ä¸º 4 ä¸ª float
};

sr_matrices sr_data;

for (int i = 0; i < unique_sr_count; i++) {
    uint32_t sr = unique_srs[i];

    if (sr == 0) {
        // å•ä½çŸ©é˜µ
        sr_data.matrices[i] = {1, 0, 0, 1};
    } else {
        // è§£ç  scale å’Œ rotation
        float scale = decode_scale(sr >> 12);
        float rotation = decode_rotation(sr & 0xFFF);

        // ç”Ÿæˆ 2x2 çŸ©é˜µ
        float cos_r = cosf(rotation);
        float sin_r = sinf(rotation);

        sr_data.matrices[i] = {
            scale * cos_r, scale * -sin_r,
            scale * sin_r, scale * cos_r
        };
    }
}

// ä¸Šä¼ åˆ° GPU
sg_apply_uniforms(SG_SHADERSTAGE_VS, 0, &SG_RANGE(sr_data));
```

#### æ­¥éª¤ 5: æäº¤æ¸²æŸ“

```c
// æ›´æ–°é¡¶ç‚¹ç¼“å†²åŒº
sg_update_buffer(vbuf, &SG_RANGE(vertices));
sg_update_buffer(ibuf, &SG_RANGE(indices));

// ç»˜åˆ¶
sg_apply_pipeline(pip);
sg_apply_bindings(&(sg_bindings){
    .vertex_buffers[0] = vbuf,
    .index_buffer = ibuf,
    .fs.images[0] = atlas_texture
});
sg_draw(0, index_count, 1);
```

---

## ğŸ® ç€è‰²å™¨è®¾è®¡

### é¡¶ç‚¹ç€è‰²å™¨

```glsl
#version 330

// è¾“å…¥
layout(location=0) in vec2 in_pos;       // ä½ç½®
layout(location=1) in vec2 in_uv;        // UV åæ ‡
layout(location=2) in int  in_sr_idx;    // SR çŸ©é˜µç´¢å¼•

// è¾“å‡º
out vec2 frag_uv;

// Uniform
uniform mat4 u_projection;               // æŠ•å½±çŸ©é˜µ
uniform mat2 u_sr_matrices[4096];        // SR å˜æ¢çŸ©é˜µæ•°ç»„

void main() {
    // åº”ç”¨ SR å˜æ¢
    vec2 transformed_pos = in_pos;
    if (in_sr_idx > 0) {
        mat2 sr = u_sr_matrices[in_sr_idx];
        transformed_pos = sr * in_pos;
    }

    // æŠ•å½±åˆ°å±å¹•ç©ºé—´
    gl_Position = u_projection * vec4(transformed_pos, 0.0, 1.0);

    // ä¼ é€’ UV
    frag_uv = in_uv;
}
```

### ç‰‡æ®µç€è‰²å™¨

```glsl
#version 330

// è¾“å…¥
in vec2 frag_uv;

// è¾“å‡º
out vec4 out_color;

// Uniform
uniform sampler2D u_atlas;  // çº¹ç†å›¾é›†

void main() {
    // ä»å›¾é›†é‡‡æ ·
    out_color = texture(u_atlas, frag_uv);

    // Alpha æµ‹è¯•(å¯é€‰)
    if (out_color.a < 0.01) {
        discard;
    }
}
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 1. æ‰¹æ¬¡åˆå¹¶

```c
// âŒ å·®:æ¯ä¸ªç²¾çµä¸€ä¸ªæ‰¹æ¬¡
for (sprite in sprites) {
    batch = batch_new(1);
    batch->stream[0] = sprite;
    batch_grab(batch);
}
// ç»“æœ: 1000 ä¸ª sprite = 1000 æ¬¡ draw call

// âœ… å¥½:æ‰€æœ‰ç²¾çµåœ¨ä¸€ä¸ªæ‰¹æ¬¡
batch = batch_new(1000);
for (i, sprite in sprites) {
    batch->stream[i] = sprite;
}
batch->n = 1000;
batch_grab(batch);
// ç»“æœ: 1000 ä¸ª sprite = 1 æ¬¡ draw call
```

### 2. SR ç´¢å¼•å¤ç”¨

```c
// å¦‚æœå¤šä¸ªç²¾çµå…±äº«ç›¸åŒçš„ SR å€¼
// GPU å¯ä»¥é‡ç”¨çŸ©é˜µè®¡ç®—

// æ„å»º SR -> index æ˜ å°„è¡¨
map<uint32_t, int> sr_index_map;
int next_index = 0;

for (prim in batch) {
    if (prim->sr == 0) {
        prim->sr_idx = 0;  // é»˜è®¤çŸ©é˜µ
    } else if (sr_index_map.contains(prim->sr)) {
        prim->sr_idx = sr_index_map[prim->sr];  // å¤ç”¨
    } else {
        prim->sr_idx = ++next_index;
        sr_index_map[prim->sr] = next_index;
    }
}
```

### 3. çº¹ç†å›¾é›†ç¼“å­˜

```c
// ç¼“å­˜å·²æ‰“åŒ…çš„å›¾é›†
// é¿å…æ¯å¸§é‡æ–°æ‰“åŒ…

struct atlas_cache {
    uint64_t hash;        // å›¾é›†å†…å®¹å“ˆå¸Œ
    sg_image texture;     // GPU çº¹ç†
    bool dirty;           // æ˜¯å¦éœ€è¦æ›´æ–°
};

// åªåœ¨æ·»åŠ æ–°ç²¾çµæ—¶æ›´æ–°
if (new_sprite_added) {
    atlas.dirty = true;
}

if (atlas.dirty) {
    sg_update_image(atlas.texture, atlas.pixels);
    atlas.dirty = false;
}
```

### 4. å®šç‚¹æ•°ä¼˜åŒ–

```c
// ä½¿ç”¨ SIMD åŠ é€Ÿå®šç‚¹æ•°è®¡ç®—(x86)
__m128i x_vec = _mm_loadu_si128((__m128i*)x_coords);
__m128i scale_vec = _mm_set1_epi32(4096);
__m128 float_vec = _mm_cvtepi32_ps(_mm_div_epi32(x_vec, scale_vec));
```

---

## ğŸ§© æè´¨ç³»ç»Ÿæ‰©å±•

### è‡ªå®šä¹‰æè´¨(sprite < 0)

```c
// æ–‡å­—æ¸²æŸ“ç¤ºä¾‹
struct text_material {
    int32_t sprite;      // = -1 (æ–‡å­—æè´¨ ID)
    uint32_t color;      // RGBA é¢œè‰²
    uint32_t unicode[3]; // Unicode ç ç‚¹(æœ€å¤š 3 ä¸ªå­—ç¬¦)
};

// ç»˜åˆ¶æ–‡å­—
text_material text = {
    .sprite = -1,
    .color = 0xFF0000FF,  // çº¢è‰²
    .unicode = {0x4F60, 0x597D, 0}  // "ä½ å¥½"
};

memcpy(&batch->stream[idx], &text, sizeof(text_material));
```

### è‡ªå®šä¹‰ç€è‰²å™¨æè´¨

```c
// ç²’å­æ•ˆæœæè´¨
struct particle_material {
    int32_t sprite;      // = -2 (ç²’å­æè´¨ ID)
    float velocity[2];   // é€Ÿåº¦
    float lifetime;      // ç”Ÿå‘½å‘¨æœŸ
    uint32_t start_color;
    uint32_t end_color;
};
```

---

## ğŸ“Š å®æˆ˜æ•°æ®

### æ€§èƒ½åŸºå‡†(äº‘é£çš„æµ‹è¯•)

| åœºæ™¯ | ç²¾çµæ•°é‡ | Draw Calls | FPS |
|------|---------|-----------|-----|
| é™æ€åœºæ™¯ | 10,000 | 1 | 60+ |
| åŠ¨æ€åœºæ™¯ | 5,000 | 5 | 60+ |
| ç²’å­æ•ˆæœ | 20,000 | 10 | 60+ |

**ç¡¬ä»¶**: æ™®é€šé›†æ˜¾(Intel UHD Graphics)

### å†…å­˜å ç”¨

```
å•ä¸ª draw_primitive: 16 bytes
1000 ä¸ªç²¾çµæ‰¹æ¬¡: 16KB
çº¹ç†å›¾é›†(2048x2048 RGBA): 16MB
æ€»å†…å­˜å ç”¨: < 20MB
```

---

## ğŸ¯ æ€»ç»“

### è®¾è®¡äº®ç‚¹

1. **æç®€æ•°æ®ç»“æ„** - 16 å­—èŠ‚æè¿°ä»»æ„ 2D å…ƒç´ 
2. **SR å‹ç¼©ç¼–ç ** - èŠ‚çœå†…å­˜å’Œå¸¦å®½
3. **è¿è¡Œæ—¶å›¾é›†** - å·¥ä½œæµç®€åŒ–
4. **æ‰¹é‡æ¸²æŸ“** - æ€§èƒ½ä¼˜å¼‚
5. **å¤šçº¿ç¨‹å‹å¥½** - æ— é”è®¾è®¡

### é€‚ç”¨åœºæ™¯

âœ… 2D æ¸¸æˆ(RPG, ç­–ç•¥, å¹³å°è·³è·ƒ)
âœ… UI ç³»ç»Ÿ
âœ… ç²’å­æ•ˆæœ
âœ… 2D åœ°å›¾ç¼–è¾‘å™¨

### é™åˆ¶

âŒ å¤æ‚çš„å½¢å˜åŠ¨ç”»(ä½¿ç”¨ Spine æ‰©å±•)
âŒ 3D æ¸²æŸ“(éœ€è¦å…¶ä»–å¼•æ“)
âŒ å¤§é‡ç‹¬ç«‹çº¹ç†(å—å›¾é›†å¤§å°é™åˆ¶)

---

## ä¸‹ä¸€æ­¥å­¦ä¹ 

- ğŸ“„ [çº¹ç†å›¾é›†æ‰“åŒ…æŠ€æœ¯](./05-çº¹ç†å›¾é›†æ‰“åŒ…æŠ€æœ¯.md) - æ·±å…¥å›¾é›†ç®—æ³•
- ğŸ“„ [å˜æ¢çŸ©é˜µä¸ç¼–ç ä¼˜åŒ–](./06-å˜æ¢çŸ©é˜µä¸ç¼–ç ä¼˜åŒ–.md) - SR ç¼–ç è¯¦è§£
- ğŸ“„ [Spine éª¨éª¼åŠ¨ç”»é›†æˆ](./11-Spineéª¨éª¼åŠ¨ç”»é›†æˆ.md) - é«˜çº§åŠ¨ç”»
