# 动态链接库实战示例

## 目录
1. [基础示例：查询 malloc](#基础示例查询-malloc)
2. [进阶示例：查询自身的 main 函数](#进阶示例查询自身的-main-函数)
3. [实战示例：加载 raylib 库](#实战示例加载-raylib-库)
4. [地址比较实验](#地址比较实验)

---

## 基础示例：查询 malloc

### 示例代码 - Image #1

```c
#include <stdio.h>
#include <dlfcn.h>

int main()
{
    // 打开当前程序作为动态库（传入 NULL）
    void *lib = dlopen(NULL, RTLD_NOW);
    printf("lib = %p\n", lib);

    // 从动态库中查询 malloc 函数
    void *malloc_lib = dlsym(lib, "malloc");
    printf("malloc_lib = %p\n", malloc_lib);

    return 0;
}
```

### 编译和运行

```bash
cc -o main main.c && ./main
```

### 输出结果

```
lib = 0x7f72a3495310
malloc_lib = 0x7f72a32f40d0
```

### 解析

- `dlopen(NULL, RTLD_NOW)` 打开当前程序本身
- `dlsym(lib, "malloc")` 在当前程序的动态符号表中查找 `malloc` 函数
- 即使 `malloc` 是标准库函数，通过动态链接也能找到它的地址

---

## 进阶示例：查询自身的 main 函数

### 示例代码 - Image #2

```c
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

int main()
{
    void *lib = dlopen(NULL, RTLD_NOW);
    printf("lib = %p\n", lib);

    // 通过 dlsym 查询 malloc
    void *malloc_lib = dlsym(lib, "malloc");
    printf("malloc_lib = %p\n", malloc_lib);

    // 通过 &malloc 直接获取地址
    printf("malloc = %p\n", &malloc);

    return 0;
}
```

### 第一次编译（无 -rdynamic）

```bash
cc -o main main.c && ./main
```

**输出**：
```
lib = 0x7f6d9097310
malloc_lib = 0x7f6d907e70d0
malloc = 0x7f6d907e70d0
```

**结果分析**：
- `malloc_lib` 和 `&malloc` 地址**完全一致** ✓
- 说明通过 dlsym 查询到的就是程序中实际使用的 malloc

---

### 尝试查询 main 函数

```c
void *main_lib = dlsym(lib, "main");
printf("main_lib = %p\n", main_lib);
```

**输出**：
```
main_lib = (nil)
```

**原因**：
- 连接器**默认不会**将 `main` 函数添加到动态符号表中
- `dlsym` 无法找到 `main`，因此返回 `NULL`

---

### 第二次编译（使用 -rdynamic）

```bash
cc -rdynamic -o main main.c && ./main
```

**代码**：
```c
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

int main()
{
    void *lib = dlopen(NULL, RTLD_NOW);

    // 查询 main 函数
    void *main_lib = dlsym(lib, "main");
    printf("main_lib = %p\n", main_lib);
    printf("&main    = %p\n", &main);

    return 0;
}
```

**输出**：
```
main_lib = 0x7f6d90123456
&main    = 0x7f6d90123456
```

**结果分析**：
- 使用 `-rdynamic` 后，`main` 函数被导出到动态符号表
- `main_lib` 和 `&main` 地址**完全一致** ✓
- 现在可以通过 `dlsym` 查询到 `main` 函数了！

---

## 危险示例：递归调用 main

### 代码

```c
#include <stdio.h>
#include <dlfcn.h>

int main()
{
    void *lib = dlopen(NULL, RTLD_NOW);

    // 查询 main 并调用它
    int (*main_func)(void) = dlsym(lib, "main");

    if (main_func) {
        printf("Calling main again...\n");
        return main_func();  // ⚠️ 递归调用！
    }

    return 0;
}
```

### 编译

```bash
cc -rdynamic -o main main.c && ./main
```

### 结果

```
Calling main again...
Calling main again...
Calling main again...
Calling main again...
...
Segmentation fault (core dumped)
```

**警告**：
- main 函数调用自己会导致**无限递归**
- 最终栈溢出，程序崩溃
- 这只是演示用途，**实际开发中不要这样做！**

---

## 实战示例：加载 raylib 库

### 代码

```c
#include <stdio.h>
#include <dlfcn.h>

int main()
{
    // 加载 raylib 动态库
    void *lib = dlopen("raylib-5.5_linux_amd64/lib/libraylib.so", RTLD_NOW);
    if (!lib) {
        fprintf(stderr, "Failed to load raylib: %s\n", dlerror());
        return 1;
    }

    // 查询 InitWindow 函数
    void (*InitWindow)(int, int, const char*);
    InitWindow = dlsym(lib, "InitWindow");

    if (!InitWindow) {
        fprintf(stderr, "Failed to find InitWindow: %s\n", dlerror());
        dlclose(lib);
        return 1;
    }

    // 调用 InitWindow
    InitWindow(800, 600, "My Dynamic Window");

    printf("Window initialized successfully!\n");

    // 清理
    dlclose(lib);
    return 0;
}
```

### 编译

```bash
cc -o main main.c -ldl
```

### 说明

- 动态加载 raylib 库，而不是在编译时链接
- 可以在运行时检测库是否存在
- 适合做插件系统或可选功能

---

## 地址比较实验

### 实验目的
验证通过 `dlsym` 查询的函数地址和通过 `&` 取地址运算符获取的地址是否一致。

### 实验代码

```c
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

int main()
{
    void *lib = dlopen(NULL, RTLD_NOW);

    // 方法1：通过 dlsym 查询
    void *malloc_lib = dlsym(lib, "malloc");

    // 方法2：通过 & 运算符直接取地址
    void *malloc_addr = &malloc;

    printf("dlsym(lib, \"malloc\") = %p\n", malloc_lib);
    printf("&malloc              = %p\n", malloc_addr);
    printf("Are they equal? %s\n",
           malloc_lib == malloc_addr ? "YES ✓" : "NO ✗");

    dlclose(lib);
    return 0;
}
```

### 编译和运行

```bash
cc -o test test.c && ./test
```

### 输出

```
dlsym(lib, "malloc") = 0x7f6d907e70d0
&malloc              = 0x7f6d907e70d0
Are they equal? YES ✓
```

### 结论

- ✅ 两种方法获取的地址**完全一致**
- ✅ `dlsym` 返回的就是实际函数的地址
- ✅ 可以把自己的程序当作动态库打开并查询其中的函数

---

## 实际应用场景

### 1. 插件架构
```c
// 加载插件
void *plugin = dlopen("plugins/my_plugin.so", RTLD_NOW);
void (*plugin_init)(void) = dlsym(plugin, "plugin_init");
if (plugin_init) {
    plugin_init();
}
```

### 2. 可选依赖检测
```c
// 检测 SDL 是否可用
void *sdl = dlopen("libSDL2.so", RTLD_NOW | RTLD_NOLOAD);
if (sdl) {
    printf("SDL2 is available\n");
} else {
    printf("SDL2 not found, using fallback\n");
}
```

### 3. 热重载
```c
// 开发时可以重新加载模块而不重启程序
dlclose(old_module);
void *new_module = dlopen("module.so", RTLD_NOW);
```

### 4. 版本选择
```c
// 根据系统尝试加载不同版本的库
void *lib = dlopen("libfoo.so.3", RTLD_NOW);
if (!lib) {
    lib = dlopen("libfoo.so.2", RTLD_NOW);
}
if (!lib) {
    lib = dlopen("libfoo.so.1", RTLD_NOW);
}
```

---

## 常见陷阱

### 陷阱 1：忘记检查错误
```c
// ❌ 错误：不检查 NULL
void *lib = dlopen("nonexistent.so", RTLD_NOW);
void *func = dlsym(lib, "foo");  // lib 是 NULL，会崩溃！

// ✅ 正确：总是检查
void *lib = dlopen("nonexistent.so", RTLD_NOW);
if (!lib) {
    fprintf(stderr, "Error: %s\n", dlerror());
    return 1;
}
```

### 陷阱 2：符号未导出

```c
// ❌ 默认编译，无法查询 main
cc -o main main.c
// main_lib = (nil)

// ✅ 使用 -rdynamic 导出符号
cc -rdynamic -o main main.c
// 可以查询到 main
```




### 陷阱 3：忘记链接 dl 库


```bash
# ❌ 编译失败
cc -o main main.c
# undefined reference to `dlopen'

# ✅ 链接 dl 库
cc -o main main.c -ldl
```




### 陷阱 4：类型不匹配
```c
// ❌ 类型不安全
void *func = dlsym(lib, "foo");
((void (*)(void))func)();  // 难以阅读

// ✅ 使用类型定义
typedef void (*foo_func_t)(void);
foo_func_t func = (foo_func_t)dlsym(lib, "foo");
func();
```




---




## 调试技巧

### 查看程序导出的符号
```bash
# 查看动态符号表
nm -D ./main

# 使用 readelf
readelf -s ./main

# 只看导出的函数
nm -D ./main | grep " T "
```




### 查看程序依赖的库
```bash
ldd ./main
```

### 追踪动态库加载
```bash
LD_DEBUG=libs ./main
```

---

## 性能注意事项

- `dlopen` 和 `dlsym` 相对较慢
- 应该在初始化时调用，而不是在热路径中
- 缓存 `dlsym` 的结果以提高性能

```c
// ✅ 好的做法：初始化时查询一次
static void (*cached_func)(void) = NULL;

void init() {
    void *lib = dlopen("lib.so", RTLD_NOW);
    cached_func = dlsym(lib, "func");
}

void hot_path() {
    cached_func();  // 快速调用
}
```
